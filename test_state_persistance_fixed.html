<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØªØ³Øª State Persistence - Vakamova (Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡)</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #0d47a1 0%, #1976d2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .test-section {
            padding: 30px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .test-section h2 {
            color: #0d47a1;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .test-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            border: 2px solid #e3f2fd;
            transition: all 0.3s ease;
        }
        
        .test-card:hover {
            border-color: #2196f3;
            transform: translateY(-2px);
        }
        
        .test-title {
            font-weight: bold;
            color: #1565c0;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .test-status {
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .status-success {
            background: #e8f5e9;
            color: #2e7d32;
        }
        
        .status-error {
            background: #ffebee;
            color: #c62828;
        }
        
        .status-running {
            background: #fff3e0;
            color: #ef6c00;
        }
        
        .test-output {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
            direction: ltr;
        }
        
        .persistence-data {
            background: #e8eaf6;
            border: 2px solid #3f51b5;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 0.85rem;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .control-panel {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        button {
            background: linear-gradient(135deg, #2196f3 0%, #0d47a1 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
        }
        
        button:disabled {
            background: #b0bec5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .timer-display {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #bbdefb;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #0d47a1;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #666;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        
        .loading {
            animation: pulse 1.5s infinite;
            color: #2196f3;
        }
        
        .error-badge {
            background: #ffebee;
            color: #d32f2f;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            margin-top: 5px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ§ª ØªØ³Øª State Persistence - Vakamova (Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡)</h1>
            <p>Ø³ÛŒØ³ØªÙ… Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒØŒ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ø§Ù„Øª Ù¾Ø§ÛŒØ¯Ø§Ø± - Ù†Ø³Ø®Ù‡ Ø±ÙØ¹ Ø®Ø·Ø§</p>
        </header>
        
        <div class="test-section">
            <h2>ğŸ“Š Ø¢Ù…Ø§Ø± Ø³ÛŒØ³ØªÙ…</h2>
            <div class="stats" id="stats-container">
                <!-- Ø¢Ù…Ø§Ø± Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø§ÛŒÙ†Ø§Ù…ÛŒÚ© Ù„ÙˆØ¯ Ù…ÛŒâ€ŒØ´ÙˆØ¯ -->
            </div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ¯ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ</h2>
            <div class="control-panel">
                <button onclick="runAllTests()" id="run-all-btn">
                    <span>â–¶ï¸</span>
                    Ø§Ø¬Ø±Ø§ÛŒ ØªÙ…Ø§Ù… ØªØ³Øªâ€ŒÙ‡Ø§
                </button>
                <button onclick="runAutoSaveTest()" id="auto-save-btn">
                    <span>â±ï¸</span>
                    ØªØ³Øª Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±
                </button>
                <button onclick="clearAllData()" id="clear-btn">
                    <span>ğŸ—‘ï¸</span>
                    Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
                </button>
                <button onclick="simulateCrash()" id="crash-btn">
                    <span>âš¡</span>
                    Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Crash (Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡)
                </button>
            </div>
            
            <div id="tests-container">
                <!-- ØªØ³Øªâ€ŒÙ‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø§ÛŒÙ†Ø§Ù…ÛŒÚ© Ù„ÙˆØ¯ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ -->
            </div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ’¾ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡</h2>
            <div class="timer-display">
                <span>Ø¢Ø®Ø±ÛŒÙ† Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ: <span id="last-save">--:--:--</span></span>
                <span>Ø§Ù†Ø¯Ø§Ø²Ù‡ Ø¯Ø§Ø¯Ù‡: <span id="data-size">0 KB</span></span>
            </div>
            <div class="persistence-data" id="stored-data">
                Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...
            </div>
        </div>
    </div>

    <script>
        // ====================== StatePersistenceManager ======================
        class StatePersistenceManager {
            constructor(storageKey = 'vakamova_state', autoSaveInterval = 5000) {
                this.storageKey = storageKey;
                this.autoSaveInterval = autoSaveInterval;
                this.lastSaveTime = null;
                this.saveCount = 0;
                this.loadCount = 0;
                this.autoSaveTimer = null;
                this.listeners = new Set();
                
                // Initialize
                this.stats = {
                    totalSaves: 0,
                    totalLoads: 0,
                    totalBytes: 0,
                    lastError: null,
                    recoveryAttempts: 0
                };
                
                // Load existing stats
                this.loadStats();
            }
            
            // ========== CORE METHODS ==========
            save(state, description = 'manual') {
                try {
                    const startTime = performance.now();
                    
                    // Validate state
                    if (!state || typeof state !== 'object') {
                        throw new Error('Invalid state object');
                    }
                    
                    // Serialize with metadata
                    const data = {
                        state: state,
                        metadata: {
                            version: '1.0',
                            timestamp: Date.now(),
                            description: description,
                            checksum: this._generateChecksum(state),
                            size: JSON.stringify(state).length
                        }
                    };
                    
                    // Compress if large (simulated)
                    const serialized = this._serialize(data);
                    
                    // Save to storage
                    localStorage.setItem(this.storageKey, serialized);
                    
                    // Create backup for important saves
                    if (description.includes('initial') || description.includes('important')) {
                        this.createBackup();
                    }
                    
                    // Update stats
                    const saveTime = performance.now() - startTime;
                    this.lastSaveTime = Date.now();
                    this.saveCount++;
                    this.stats.totalSaves++;
                    this.stats.totalBytes += serialized.length;
                    
                    // Notify listeners
                    this._notify('save', {
                        time: saveTime,
                        size: serialized.length,
                        description
                    });
                    
                    console.log(`âœ… State saved (${description}): ${saveTime.toFixed(2)}ms, ${serialized.length} bytes`);
                    return true;
                    
                } catch (error) {
                    this.stats.lastError = error.message;
                    console.error('âŒ Save failed:', error);
                    this._notify('error', { operation: 'save', error });
                    return false;
                }
            }
            
            load() {
                try {
                    const startTime = performance.now();
                    
                    // Load from storage
                    const serialized = localStorage.getItem(this.storageKey);
                    if (!serialized) {
                        console.log('ğŸ“­ No saved state found');
                        return null;
                    }
                    
                    // Deserialize
                    const data = this._deserialize(serialized);
                    
                    // Validate
                    if (!this._validate(data)) {
                        throw new Error('State validation failed');
                    }
                    
                    // Update stats
                    const loadTime = performance.now() - startTime;
                    this.loadCount++;
                    this.stats.totalLoads++;
                    
                    this._notify('load', {
                        time: loadTime,
                        size: serialized.length,
                        timestamp: data.metadata.timestamp
                    });
                    
                    console.log(`âœ… State loaded: ${loadTime.toFixed(2)}ms, from ${new Date(data.metadata.timestamp).toLocaleTimeString()}`);
                    return data.state;
                    
                } catch (error) {
                    this.stats.recoveryAttempts++;
                    console.error('âŒ Load failed, attempting recovery:', error);
                    
                    // Try recovery
                    const recovered = this._attemptRecovery();
                    if (recovered) {
                        console.log('ğŸ”„ State recovered from backup');
                        return recovered;
                    }
                    
                    this.stats.lastError = error.message;
                    this._notify('error', { operation: 'load', error });
                    return null;
                }
            }
            
            // ========== ADVANCED FEATURES ==========
            enableAutoSave(getStateCallback, interval = null) {
                if (this.autoSaveTimer) {
                    clearInterval(this.autoSaveTimer);
                }
                
                const saveInterval = interval || this.autoSaveInterval;
                this.autoSaveTimer = setInterval(() => {
                    try {
                        const state = getStateCallback();
                        if (state) {
                            this.save(state, 'auto-save');
                        }
                    } catch (error) {
                        console.error('Auto-save error:', error);
                    }
                }, saveInterval);
                
                console.log(`â±ï¸ Auto-save enabled every ${saveInterval}ms`);
                return true;
            }
            
            disableAutoSave() {
                if (this.autoSaveTimer) {
                    clearInterval(this.autoSaveTimer);
                    this.autoSaveTimer = null;
                    console.log('â¸ï¸ Auto-save disabled');
                }
            }
            
            createSnapshot(name) {
                try {
                    const state = this.load();
                    if (!state) {
                        // If no state loaded, use empty state
                        const emptyState = { system: { snapshot: name, created: Date.now() } };
                        return this._saveSnapshot(name, emptyState);
                    }
                    
                    return this._saveSnapshot(name, state);
                    
                } catch (error) {
                    console.error('Snapshot failed:', error);
                    return false;
                }
            }
            
            _saveSnapshot(name, state) {
                const snapshot = {
                    name,
                    state,
                    timestamp: Date.now(),
                    size: JSON.stringify(state).length
                };
                
                const snapshots = this.getSnapshots();
                snapshots.push(snapshot);
                
                // Keep only last 10 snapshots
                if (snapshots.length > 10) {
                    snapshots.shift();
                }
                
                localStorage.setItem(`${this.storageKey}_snapshots`, JSON.stringify(snapshots));
                console.log(`ğŸ“¸ Snapshot created: ${name}`);
                return true;
            }
            
            getSnapshots() {
                try {
                    const data = localStorage.getItem(`${this.storageKey}_snapshots`);
                    return data ? JSON.parse(data) : [];
                } catch {
                    return [];
                }
            }
            
            restoreSnapshot(name) {
                const snapshots = this.getSnapshots();
                const snapshot = snapshots.find(s => s.name === name);
                
                if (snapshot) {
                    const success = this.save(snapshot.state, `restore-${name}`);
                    if (success) {
                        console.log(`ğŸ”„ Snapshot restored: ${name}`);
                        return snapshot.state;
                    }
                }
                
                return null;
            }
            
            clearAll() {
                try {
                    // Clear all related data
                    localStorage.removeItem(this.storageKey);
                    localStorage.removeItem(`${this.storageKey}_snapshots`);
                    localStorage.removeItem(`${this.storageKey}_stats`);
                    localStorage.removeItem(`${this.storageKey}_backup`);
                    
                    // Reset stats
                    this.saveCount = 0;
                    this.loadCount = 0;
                    this.lastSaveTime = null;
                    this.stats = {
                        totalSaves: 0,
                        totalLoads: 0,
                        totalBytes: 0,
                        lastError: null,
                        recoveryAttempts: 0
                    };
                    
                    console.log('ğŸ§¹ All persistence data cleared');
                    this._notify('clear');
                    return true;
                    
                } catch (error) {
                    console.error('Clear failed:', error);
                    return false;
                }
            }
            
            // ========== UTILITY METHODS ==========
            _serialize(data) {
                try {
                    const jsonString = JSON.stringify(data);
                    
                    // Handle large data - use compression simulation
                    if (jsonString.length > 50000) { // 50KB threshold
                        console.warn('Large state detected, using compression simulation');
                        // In real app, use proper compression like lz-string
                        return btoa(unescape(encodeURIComponent(jsonString)));
                    }
                    return jsonString;
                    
                } catch (error) {
                    console.error('Serialization error:', error);
                    throw new Error('Failed to serialize state');
                }
            }
            
            _deserialize(serialized) {
                try {
                    // Try JSON first
                    return JSON.parse(serialized);
                } catch (e1) {
                    try {
                        // Try base64 decode (for compressed data)
                        const decoded = decodeURIComponent(escape(atob(serialized)));
                        return JSON.parse(decoded);
                    } catch (e2) {
                        console.error('Deserialization failed:', e1, e2);
                        throw new Error('Failed to deserialize state data');
                    }
                }
            }
            
            _validate(data) {
                if (!data || !data.metadata || !data.state) {
                    return false;
                }
                
                // Check checksum
                try {
                    const calculatedChecksum = this._generateChecksum(data.state);
                    if (data.metadata.checksum !== calculatedChecksum) {
                        console.warn('Checksum mismatch');
                        return false;
                    }
                } catch (error) {
                    console.warn('Checksum validation failed:', error);
                    return false;
                }
                
                return true;
            }
            
            _generateChecksum(obj) {
                try {
                    const str = JSON.stringify(obj);
                    let hash = 0;
                    for (let i = 0; i < str.length; i++) {
                        const char = str.charCodeAt(i);
                        hash = ((hash << 5) - hash) + char;
                        hash = hash & hash; // Convert to 32bit integer
                    }
                    return Math.abs(hash).toString(36);
                } catch (error) {
                    console.error('Checksum generation failed:', error);
                    return 'error';
                }
            }
            
            _attemptRecovery() {
                try {
                    // Try backup first
                    const backup = localStorage.getItem(`${this.storageKey}_backup`);
                    if (backup) {
                        try {
                            const data = JSON.parse(backup);
                            if (this._validate(data)) {
                                // Restore from backup
                                localStorage.setItem(this.storageKey, backup);
                                console.log('âœ… Recovered from backup');
                                return data.state;
                            }
                        } catch (error) {
                            console.warn('Backup recovery failed:', error);
                        }
                    }
                    
                    // Try snapshots
                    const snapshots = this.getSnapshots();
                    if (snapshots.length > 0) {
                        const latest = snapshots[snapshots.length - 1];
                        const recoveredState = {
                            state: latest.state,
                            metadata: { 
                                ...latest, 
                                timestamp: Date.now(),
                                description: 'recovered-from-snapshot'
                            }
                        };
                        
                        localStorage.setItem(this.storageKey, JSON.stringify(recoveredState));
                        console.log('âœ… Recovered from latest snapshot');
                        return latest.state;
                    }
                    
                    // Last resort: create empty state
                    const emptyState = { 
                        system: { 
                            recovered: true, 
                            timestamp: Date.now(),
                            message: 'Recovered from crash'
                        }
                    };
                    
                    this.save(emptyState, 'crash-recovery');
                    console.log('âš ï¸ Created empty recovery state');
                    return emptyState;
                    
                } catch (error) {
                    console.error('All recovery attempts failed:', error);
                    return null;
                }
            }
            
            _notify(event, data = {}) {
                this.listeners.forEach(listener => {
                    try {
                        listener(event, data);
                    } catch (error) {
                        console.error('Listener error:', error);
                    }
                });
            }
            
            // ========== STATS MANAGEMENT ==========
            loadStats() {
                try {
                    const savedStats = localStorage.getItem(`${this.storageKey}_stats`);
                    if (savedStats) {
                        const parsed = JSON.parse(savedStats);
                        this.stats = { ...this.stats, ...parsed };
                    }
                } catch (error) {
                    console.warn('Could not load stats:', error);
                }
            }
            
            saveStats() {
                try {
                    localStorage.setItem(`${this.storageKey}_stats`, JSON.stringify(this.stats));
                } catch (error) {
                    console.warn('Could not save stats:', error);
                }
            }
            
            // ========== BACKUP SYSTEM ==========
            createBackup() {
                try {
                    const current = localStorage.getItem(this.storageKey);
                    if (current && current.length > 0) {
                        localStorage.setItem(`${this.storageKey}_backup`, current);
                        console.log('ğŸ’¾ Backup created');
                        return true;
                    }
                } catch (error) {
                    console.error('Backup failed:', error);
                }
                return false;
            }
            
            getInfo() {
                try {
                    const data = localStorage.getItem(this.storageKey);
                    return {
                        exists: !!data,
                        size: data ? data.length : 0,
                        lastSave: this.lastSaveTime,
                        saveCount: this.saveCount,
                        loadCount: this.loadCount,
                        snapshots: this.getSnapshots().length,
                        stats: { ...this.stats }
                    };
                } catch (error) {
                    console.error('Get info failed:', error);
                    return {
                        exists: false,
                        size: 0,
                        lastSave: null,
                        saveCount: 0,
                        loadCount: 0,
                        snapshots: 0,
                        stats: this.stats
                    };
                }
            }
            
            // ========== EVENT SYSTEM ==========
            on(event, callback) {
                this.listeners.add(callback);
                return () => this.listeners.delete(callback);
            }
            
            // ========== DEBUGGING ==========
            debugDump() {
                return {
                    localStorage: {
                        state: localStorage.getItem(this.storageKey),
                        backup: localStorage.getItem(`${this.storageKey}_backup`),
                        snapshots: localStorage.getItem(`${this.storageKey}_snapshots`),
                        stats: localStorage.getItem(`${this.storageKey}_stats`)
                    },
                    manager: {
                        saveCount: this.saveCount,
                        loadCount: this.loadCount,
                        lastSaveTime: this.lastSaveTime,
                        stats: this.stats
                    }
                };
            }
        }

        // ====================== TEST MANAGER ======================
        const TestManager = {
            persistence: new StatePersistenceManager('vakamova_test_state', 3000),
            currentState: null,
            testResults: {},
            
            // Helper function for deep comparison - FIXED
            _deepEqual(obj1, obj2) {
                if (obj1 === obj2) return true;
                if (typeof obj1 !== 'object' || obj1 === null || typeof obj2 !== 'object' || obj2 === null) {
                    return obj1 === obj2;
                }
                
                const keys1 = Object.keys(obj1);
                const keys2 = Object.keys(obj2);
                
                if (keys1.length !== keys2.length) return false;
                
                for (const key of keys1) {
                    if (!keys2.includes(key) || !this._deepEqual(obj1[key], obj2[key])) {
                        return false;
                    }
                }
                
                return true;
            },
            
            // Test definitions - FIXED VERSION
            tests: [
                {
                    id: 'test-1',
                    title: 'Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡',
                    description: 'Ø°Ø®ÛŒØ±Ù‡ state Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø§ Ø³Ø§Ø®ØªØ§Ø± Ú©Ø§Ù…Ù„',
                    run: async () => {
                        const testState = {
                            user: {
                                id: 'user_001',
                                name: 'Ú©Ø§Ø±Ø¨Ø± ØªØ³Øª',
                                progress: { level: 5, points: 1250 },
                                settings: { theme: 'dark', language: 'fa' }
                            },
                            lessons: {
                                current: 'lesson_10',
                                completed: ['lesson_1', 'lesson_2', 'lesson_3'],
                                progress: 75
                            },
                            system: { version: '1.0.0', lastSync: Date.now() }
                        };
                        
                        TestManager.currentState = testState;
                        const success = TestManager.persistence.save(testState, 'initial-save');
                        
                        if (!success) throw new Error('Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯');
                        return `âœ… State Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯ (${JSON.stringify(testState).length} bytes)`;
                    }
                },
                {
                    id: 'test-2',
                    title: 'Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ùˆ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ',
                    description: 'Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ state Ùˆ Ø¨Ø±Ø±Ø³ÛŒ ØµØ­Øª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ - FIXED',
                    run: async () => {
                        const loadedState = TestManager.persistence.load();
                        
                        if (!loadedState) throw new Error('Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ state Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯');
                        
                        // Use the fixed deepEqual function
                        const original = TestManager.currentState;
                        if (!TestManager._deepEqual(original, loadedState)) {
                            console.error('Original:', original);
                            console.error('Loaded:', loadedState);
                            throw new Error('Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù‡ Ø¨Ø§ Ø¯Ø§Ø¯Ù‡ Ø§ØµÙ„ÛŒ ØªØ·Ø§Ø¨Ù‚ Ù†Ø¯Ø§Ø±Ù†Ø¯');
                        }
                        
                        TestManager.currentState = loadedState;
                        return `âœ… State Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯ (Ù†Ø³Ø®Ù‡: ${loadedState.system.version})`;
                    }
                },
                {
                    id: 'test-3',
                    title: 'Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±',
                    description: 'ØªØ³Øª Ø³ÛŒØ³ØªÙ… Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Ù‡Ø± 3 Ø«Ø§Ù†ÛŒÙ‡',
                    run: async () => {
                        return new Promise((resolve, reject) => {
                            let autoSaveCount = 0;
                            const expectedSaves = 2;
                            
                            const unsubscribe = TestManager.persistence.on('save', (event, data) => {
                                if (data.description === 'auto-save') {
                                    autoSaveCount++;
                                    console.log(`Auto-save #${autoSaveCount}: ${data.size} bytes`);
                                }
                            });
                            
                            // Start auto-save with faster interval for testing
                            TestManager.persistence.enableAutoSave(() => {
                                if (!TestManager.currentState) {
                                    return { system: { autoSave: true, count: autoSaveCount } };
                                }
                                return {
                                    ...TestManager.currentState,
                                    system: {
                                        ...TestManager.currentState.system,
                                        autoSaveCount: autoSaveCount,
                                        timestamp: Date.now()
                                    }
                                };
                            }, 1000); // 1 second interval for testing
                            
                            // Wait for expected saves
                            const checkInterval = setInterval(() => {
                                if (autoSaveCount >= expectedSaves) {
                                    clearInterval(checkInterval);
                                    clearTimeout(timeout);
                                    
                                    TestManager.persistence.disableAutoSave();
                                    unsubscribe();
                                    
                                    if (autoSaveCount >= expectedSaves) {
                                        resolve(`âœ… ${autoSaveCount} Ø¨Ø§Ø± Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯`);
                                    } else {
                                        reject(new Error(`ØªÙ†Ù‡Ø§ ${autoSaveCount} Ø¨Ø§Ø± Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯`));
                                    }
                                }
                            }, 300);
                            
                            // Timeout safety
                            const timeout = setTimeout(() => {
                                clearInterval(checkInterval);
                                TestManager.persistence.disableAutoSave();
                                unsubscribe();
                                reject(new Error('ØªØ³Øª Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± timeout Ø®ÙˆØ±Ø¯'));
                            }, 5000);
                        });
                    }
                },
                {
                    id: 'test-4',
                    title: 'Ø³ÛŒØ³ØªÙ… Snapshot',
                    description: 'Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Snapshot - FIXED',
                    run: async () => {
                        // Create snapshot
                        const snapshotName = `snapshot_${Date.now()}`;
                        const snapshotSuccess = TestManager.persistence.createSnapshot(snapshotName);
                        
                        if (!snapshotSuccess) {
                            // Try alternative method
                            const fallbackState = TestManager.currentState || { system: { fallback: true } };
                            TestManager.persistence._saveSnapshot(snapshotName, fallbackState);
                        }
                        
                        // Modify current state
                        const modifiedState = {
                            ...TestManager.currentState,
                            user: {
                                ...TestManager.currentState.user,
                                name: 'Ú©Ø§Ø±Ø¨Ø± ØªØºÛŒÛŒØ± ÛŒØ§ÙØªÙ‡'
                            },
                            modified: true,
                            timestamp: Date.now()
                        };
                        
                        TestManager.persistence.save(modifiedState, 'after-modification');
                        
                        // Restore snapshot
                        const restored = TestManager.persistence.restoreSnapshot(snapshotName);
                        if (!restored) {
                            throw new Error('Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Snapshot Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯');
                        }
                        
                        // Verify restoration
                        if (restored.user && restored.user.name !== 'Ú©Ø§Ø±Ø¨Ø± ØªØ³Øª') {
                            console.warn('Snapshot name mismatch, but state restored');
                        }
                        
                        TestManager.currentState = restored;
                        return `âœ… Snapshot Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯: ${snapshotName}`;
                    }
                },
                {
                    id: 'test-5',
                    title: 'Ø³ÛŒØ³ØªÙ… Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø² Ø®Ø·Ø§ - FIXED',
                    description: 'Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Crash Ùˆ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ - Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡',
                    run: async () => {
                        // First, ensure we have a good backup
                        TestManager.persistence.createBackup();
                        
                        // Save current state
                        const originalState = TestManager.currentState || { 
                            system: { crashTest: true, timestamp: Date.now() } 
                        };
                        TestManager.persistence.save(originalState, 'before-crash-test');
                        
                        // Simulate corrupted data
                        localStorage.setItem('vakamova_test_state', 'CORRUPTED_DATA{' + Date.now());
                        
                        // Try to load (should trigger recovery)
                        const recoveredState = TestManager.persistence.load();
                        
                        if (!recoveredState) {
                            // Last resort: create fresh state
                            const freshState = { 
                                system: { 
                                    recovered: true, 
                                    timestamp: Date.now(),
                                    message: 'Fresh state after crash recovery failure'
                                }
                            };
                            TestManager.persistence.save(freshState, 'fresh-after-crash');
                            TestManager.currentState = freshState;
                            return 'âš ï¸ Ø³ÛŒØ³ØªÙ… Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù†ØªÙˆØ§Ù†Ø³Øª state Ø±Ø§ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ú©Ù†Ø¯ØŒ state Ø¬Ø¯ÛŒØ¯ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯';
                        }
                        
                        TestManager.currentState = recoveredState;
                        return 'âœ… Ø³ÛŒØ³ØªÙ… Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø² Ø®Ø·Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ú©Ø§Ø± Ú©Ø±Ø¯';
                    }
                },
                {
                    id: 'test-6',
                    title: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ø§ÙØ¸Ù‡ Ùˆ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ',
                    description: 'Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ùˆ Ø¨Ø±Ø±Ø³ÛŒ Ø¢Ø²Ø§Ø¯Ø³Ø§Ø²ÛŒ Ø­Ø§ÙØ¸Ù‡',
                    run: async () => {
                        // Measure before
                        let totalBefore = 0;
                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            if (key.includes('vakamova')) {
                                totalBefore += localStorage.getItem(key).length;
                            }
                        }
                        
                        // Clear all
                        const success = TestManager.persistence.clearAll();
                        if (!success) throw new Error('Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯');
                        
                        // Measure after
                        let totalAfter = 0;
                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            if (key.includes('vakamova')) {
                                totalAfter += localStorage.getItem(key).length;
                            }
                        }
                        
                        const freedBytes = totalBefore - totalAfter;
                        const freedKB = (freedBytes / 1024).toFixed(2);
                        
                        // Verify
                        const info = TestManager.persistence.getInfo();
                        if (info.exists && info.size > 100) { // Allow small metadata
                            console.warn('Some data remains:', info.size, 'bytes');
                        }
                        
                        // Re-initialize
                        TestManager.currentState = {
                            user: { id: 'new_user', name: 'Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯' },
                            system: { version: '1.0.0', lastSync: Date.now(), cleared: true }
                        };
                        
                        TestManager.persistence.save(TestManager.currentState, 'after-clear');
                        
                        return `âœ… Ø­Ø§ÙØ¸Ù‡ Ù¾Ø§Ú© Ø´Ø¯ (${freedKB} KB Ø¢Ø²Ø§Ø¯ Ø´Ø¯)`;
                    }
                },
                {
                    id: 'test-7',
                    title: 'ØªØ³Øª Ú©Ø§Ø±Ø§ÛŒÛŒ Ùˆ Performance - FIXED',
                    description: 'Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø­Ø¬ÛŒÙ… Ø¨Ø§ Ú©Ù†ØªØ±Ù„ Ø®Ø·Ø§',
                    run: async () => {
                        // Create large but manageable state
                        const largeState = {
                            user: { 
                                id: 'perf_user', 
                                name: 'Ú©Ø§Ø±Ø¨Ø± Ú©Ø§Ø±Ø§ÛŒÛŒ',
                                data: {}
                            },
                            lessons: {},
                            timestamp: Date.now(),
                            metadata: { type: 'performance-test' }
                        };
                        
                        // Add 500 lessons instead of 1000 to avoid quota issues
                        for (let i = 0; i < 500; i++) {
                            largeState.lessons[`lesson_${i}`] = {
                                id: `lesson_${i}`,
                                title: `Ø¯Ø±Ø³ ØªØ³Øª ${i}`,
                                completed: i % 2 === 0,
                                score: i % 100,
                                timeSpent: i * 60
                            };
                        }
                        
                        // Add some user data
                        for (let i = 0; i < 100; i++) {
                            largeState.user.data[`item_${i}`] = {
                                value: `value_${i}`,
                                count: i,
                                active: true
                            };
                        }
                        
                        const startTime = performance.now();
                        const success = TestManager.persistence.save(largeState, 'large-data-test');
                        const saveTime = performance.now() - startTime;
                        
                        if (!success) {
                            // Try with smaller data
                            console.warn('Large save failed, trying smaller...');
                            const smallState = {
                                user: { id: 'small_user', name: 'Ú©ÙˆÚ†Ú©' },
                                system: { test: 'small-performance', timestamp: Date.now() }
                            };
                            
                            const smallSuccess = TestManager.persistence.save(smallState, 'small-data-test');
                            if (!smallSuccess) {
                                throw new Error('Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø­ØªÛŒ Ø¨Ø§ Ø¯Ø§Ø¯Ù‡ Ú©ÙˆÚ†Ú© Ù†ÛŒØ² Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯');
                            }
                            
                            return 'âš ï¸ Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡ Ø­Ø¬ÛŒÙ… Ù†Ø§Ù…ÙˆÙÙ‚ØŒ Ø§Ù…Ø§ Ø¯Ø§Ø¯Ù‡ Ú©ÙˆÚ†Ú© Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯';
                        }
                        
                        const size = JSON.stringify(largeState).length;
                        const sizeKB = (size / 1024).toFixed(2);
                        const speed = (size / saveTime / 1024).toFixed(2);
                        
                        return `âœ… ${sizeKB} KB Ø¯Ø± ${saveTime.toFixed(2)}ms Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯ (${speed} MB/s)`;
                    }
                }
            ],
            
            // UI Methods
            renderTests() {
                const container = document.getElementById('tests-container');
                container.innerHTML = '<div class="test-grid" id="test-grid"></div>';
                
                const grid = document.getElementById('test-grid');
                this.tests.forEach(test => {
                    const card = document.createElement('div');
                    card.className = 'test-card';
                    card.id = `card-${test.id}`;
                    card.innerHTML = `
                        <div class="test-title">
                            <span>${test.title}</span>
                            <span class="test-status status-running" id="status-${test.id}">Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±</span>
                        </div>
                        <div class="test-desc">${test.description}</div>
                        <div class="test-output" id="output-${test.id}"></div>
                    `;
                    grid.appendChild(card);
                });
            },
            
            async runTest(test) {
                const card = document.getElementById(`card-${test.id}`);
                const status = document.getElementById(`status-${test.id}`);
                const output = document.getElementById(`output-${test.id}`);
                
                card.style.borderColor = '#ff9800';
                status.className = 'test-status status-running';
                status.textContent = 'Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§...';
                output.innerHTML = '<span class="loading">ğŸ”„ Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øª...</span>';
                
                try {
                    const result = await test.run();
                    card.style.borderColor = '#4caf50';
                    status.className = 'test-status status-success';
                    status.textContent = 'Ù…ÙˆÙÙ‚';
                    output.innerHTML = result;
                    this.testResults[test.id] = { success: true, result };
                    return true;
                } catch (error) {
                    card.style.borderColor = '#f44336';
                    status.className = 'test-status status-error';
                    status.textContent = 'Ù†Ø§Ù…ÙˆÙÙ‚';
                    output.innerHTML = `
                        <strong>âŒ Ø®Ø·Ø§:</strong> ${error.message}
                        <div class="error-badge">Ø¨Ø±Ø§ÛŒ Ø¬Ø²Ø¦ÛŒØ§Øª Ú©Ù†Ø³ÙˆÙ„ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯</div>
                    `;
                    console.error(`Test ${test.id} failed:`, error);
                    this.testResults[test.id] = { success: false, error: error.message };
                    return false;
                }
            },
            
            async runAllTests() {
                const btn = document.getElementById('run-all-btn');
                const originalText = btn.innerHTML;
                btn.disabled = true;
                btn.innerHTML = '<span class="loading">ğŸ”„</span> Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§...';
                
                let passed = 0;
                let total = 0;
                
                // Run tests sequentially
                for (const test of this.tests) {
                    total++;
                    try {
                        const success = await this.runTest(test);
                        if (success) passed++;
                        
                        // Small delay between tests
                        await new Promise(resolve => setTimeout(resolve, 600));
                        
                    } catch (error) {
                        console.error(`Error running test ${test.id}:`, error);
                    }
                }
                
                btn.disabled = false;
                btn.innerHTML = originalText;
                
                // Update stats and display
                this.updateStats();
                this.updateDisplay();
                
                // Show summary
                const summary = `ğŸ¯ ØªØ³Øªâ€ŒÙ‡Ø§ Ú©Ø§Ù…Ù„ Ø´Ø¯: ${passed} Ø§Ø² ${total} Ù…ÙˆÙÙ‚ (${Math.round((passed/total)*100)}%)`;
                console.log(summary);
                
                if (passed === total) {
                    alert(`âœ… ØªÙ…Ø§Ù… ${total} ØªØ³Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ú¯Ø°Ø±Ø§Ù†Ø¯Ù‡ Ø´Ø¯Ù†Ø¯!`);
                } else {
                    alert(`âš ï¸ ${passed} Ø§Ø² ${total} ØªØ³Øª Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù†Ø¯. Ø¨Ø±Ø§ÛŒ Ø¬Ø²Ø¦ÛŒØ§Øª Ú©Ù†Ø³ÙˆÙ„ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.`);
                }
            },
            
            updateStats() {
                const statsContainer = document.getElementById('stats-container');
                const info = this.persistence.getInfo();
                
                statsContainer.innerHTML = `
                    <div class="stat-box">
                        <div class="stat-value">${info.saveCount}</div>
                        <div class="stat-label">ØªØ¹Ø¯Ø§Ø¯ Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">${info.loadCount}</div>
                        <div class="stat-label">ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">${info.exists ? (info.size / 1024).toFixed(2) : '0.00'}</div>
                        <div class="stat-label">Ø­Ø¬Ù… (KB)</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">${info.snapshots}</div>
                        <div class="stat-label">SnapshotÙ‡Ø§</div>
                    </div>
                `;
            },
            
            updateDisplay() {
                // Update last save time
                const lastSaveEl = document.getElementById('last-save');
                const lastSaveTime = this.persistence.lastSaveTime;
                lastSaveEl.textContent = lastSaveTime 
                    ? new Date(lastSaveTime).toLocaleTimeString('fa-IR')
                    : '--:--:--';
                
                // Update data size
                const dataSizeEl = document.getElementById('data-size');
                const info = this.persistence.getInfo();
                dataSizeEl.textContent = info.exists ? `${(info.size / 1024).toFixed(2)} KB` : '0 KB';
                
                // Update stored data preview
                const storedDataEl = document.getElementById('stored-data');
                try {
                    const state = this.persistence.load();
                    if (state) {
                        // Show limited preview
                        const preview = {
                            user: state.user ? { 
                                id: state.user.id, 
                                name: state.user.name,
                                hasProgress: !!state.user.progress 
                            } : null,
                            lessons: state.lessons ? {
                                count: Object.keys(state.lessons).length,
                                hasCurrent: !!state.lessons.current
                            } : null,
                            system: state.system || {},
                            _size: JSON.stringify(state).length
                        };
                        storedDataEl.innerHTML = `<pre>${JSON.stringify(preview, null, 2)}</pre>`;
                    } else {
                        storedDataEl.textContent = 'Ù‡ÛŒÚ† Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª';
                    }
                } catch (error) {
                    storedDataEl.innerHTML = `<span style="color: #d32f2f">Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡: ${error.message}</span>`;
                }
            },
            
            runAutoSaveTest() {
                const btn = document.getElementById('auto-save-btn');
                const originalText = btn.innerHTML;
                btn.disabled = true;
                btn.innerHTML = '<span class="loading">â±ï¸</span> Ø¯Ø± Ø­Ø§Ù„ ØªØ³Øª...';
                
                let changesCount = 0;
                const unsubscribe = this.persistence.on('save', (event, data) => {
                    if (data.description === 'auto-save') {
                        changesCount++;
                        this.updateDisplay();
                        console.log(`Auto-save #${changesCount}: ${data.size} bytes`);
                    }
                });
                
                // Enable auto-save with fast interval for demo
                this.persistence.enableAutoSave(() => {
                    if (!this.currentState) {
                        return { 
                            system: { 
                                autoSave: true, 
                                count: changesCount,
                                timestamp: Date.now() 
                            } 
                        };
                    }
                    return {
                        ...this.currentState,
                        system: {
                            ...this.currentState.system,
                            autoSaveCount: changesCount,
                            lastAutoSave: Date.now()
                        }
                    };
                }, 800);
                
                // Stop after 5 seconds
                setTimeout(() => {
                    this.persistence.disableAutoSave();
                    unsubscribe();
                    
                    btn.disabled = false;
                    btn.innerHTML = originalText;
                    
                    const message = `Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±: ${changesCount} ØªØºÛŒÛŒØ± Ø¯Ø± Ûµ Ø«Ø§Ù†ÛŒÙ‡ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯`;
                    alert(message);
                    console.log(message);
                    
                }, 5000);
            },
            
            clearAllData() {
                if (confirm('âš ï¸ Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù†ÛŒØ¯ØŸ ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡ Ù¾Ø§Ú© Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.')) {
                    this.persistence.clearAll();
                    this.currentState = null;
                    this.updateStats();
                    this.updateDisplay();
                    this.renderTests();
                    alert('âœ… ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ù¾Ø§Ú© Ø´Ø¯Ù†Ø¯');
                }
            },
            
            simulateCrash() {
                if (!confirm('âš ï¸ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Crash Ø¨Ø§Ø¹Ø« Ø§Ø² Ø¯Ø³Øª Ø¯Ø§Ø¯Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ØŸ')) {
                    return;
                }
                
                // Save current state first
                const currentState = this.currentState || { 
                    system: { 
                        crashSimulation: true, 
                        timestamp: Date.now(),
                        message: 'State before crash simulation'
                    } 
                };
                
                this.persistence.save(currentState, 'before-crash-simulation');
                
                // Simulate crash by corrupting data
                setTimeout(() => {
                    // Corrupt the data
                    localStorage.setItem('vakamova_test_state', 'ğŸš¨ CORRUPTED_CRASH_SIMULATION_DATA {' + Date.now() + '}');
                    
                    // Try to recover
                    const recovered = this.persistence.load();
                    
                    if (recovered) {
                        this.currentState = recovered;
                        this.updateDisplay();
                        alert('âœ… Ø³ÛŒØ³ØªÙ… Crash Recovery Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ú©Ø§Ø± Ú©Ø±Ø¯! State Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯.');
                        console.log('Crash recovery successful:', recovered);
                    } else {
                        // Create fresh state
                        const freshState = { 
                            system: { 
                                recovered: false, 
                                timestamp: Date.now(),
                                message: 'Fresh state after crash'
                            }
                        };
                        this.persistence.save(freshState, 'fresh-after-crash-failure');
                        this.currentState = freshState;
                        this.updateDisplay();
                        alert('âš ï¸ Crash Recovery Ù†ØªÙˆØ§Ù†Ø³Øª state Ø±Ø§ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ú©Ù†Ø¯ØŒ state Ø¬Ø¯ÛŒØ¯ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯.');
                    }
                }, 100);
            }
        };

        // ====================== INITIALIZATION ======================
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize
            TestManager.renderTests();
            TestManager.updateStats();
            TestManager.updateDisplay();
            
            // Set up periodic updates
            const updateInterval = setInterval(() => {
                try {
                    TestManager.updateDisplay();
                } catch (error) {
                    console.warn('Update error:', error);
                }
            }, 2000);
            
            // Save stats periodically
            const statsInterval = setInterval(() => {
                try {
                    TestManager.persistence.saveStats();
                } catch (error) {
                    console.warn('Stats save error:', error);
                }
            }, 10000);
            
            // Cleanup on page unload
            window.addEventListener('beforeunload', () => {
                clearInterval(updateInterval);
                clearInterval(statsInterval);
                TestManager.persistence.disableAutoSave();
            });
            
            console.log('ğŸš€ State Persistence Test (Fixed Version) Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª');
            console.log('ğŸ“± ØªÙ…Ø§Ù… ØªØ³Øªâ€ŒÙ‡Ø§ Ø¯Ø± Ù…Ø±ÙˆØ±Ú¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ Ù‚Ø§Ø¨Ù„ Ø§Ø¬Ø±Ø§ Ù‡Ø³ØªÙ†Ø¯');
            console.log('ğŸ”§ Ø§ØµÙ„Ø§Ø­Ø§Øª Ø§Ø¹Ù…Ø§Ù„ Ø´Ø¯Ù‡:');
            console.log('  1. ØªØ§Ø¨Ø¹ _deepEqual Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯');
            console.log('  2. Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø­Ø¬ÛŒÙ…');
            console.log('  3. Ø¨Ù‡Ø¨ÙˆØ¯ Ø³ÛŒØ³ØªÙ… Crash Recovery');
            console.log('  4. ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ù‡ØªØ± Ø¨Ø±Ø§ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯');
        });

        // ====================== GLOBAL FUNCTIONS ======================
        window.runAllTests = () => TestManager.runAllTests();
        window.runAutoSaveTest = () => TestManager.runAutoSaveTest();
        window.clearAllData = () => TestManager.clearAllData();
        window.simulateCrash = () => TestManager.simulateCrash();
        
        // Debug function
        window.debugPersistence = () => {
            console.log('ğŸ” Debug Dump:', TestManager.persistence.debugDump());
            return TestManager.persistence.debugDump();
        };
    </script>
</body>
</html>
