<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØªØ³Øª State Persistence - Vakamova</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #0d47a1 0%, #1976d2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .test-section {
            padding: 30px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .test-section h2 {
            color: #0d47a1;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .test-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            border: 2px solid #e3f2fd;
            transition: all 0.3s ease;
        }
        
        .test-card:hover {
            border-color: #2196f3;
            transform: translateY(-2px);
        }
        
        .test-title {
            font-weight: bold;
            color: #1565c0;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .test-status {
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .status-success {
            background: #e8f5e9;
            color: #2e7d32;
        }
        
        .status-error {
            background: #ffebee;
            color: #c62828;
        }
        
        .status-running {
            background: #fff3e0;
            color: #ef6c00;
        }
        
        .test-output {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
            direction: ltr;
        }
        
        .persistence-data {
            background: #e8eaf6;
            border: 2px solid #3f51b5;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 0.85rem;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .control-panel {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        button {
            background: linear-gradient(135deg, #2196f3 0%, #0d47a1 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
        }
        
        button:disabled {
            background: #b0bec5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .timer-display {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .progress-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #bbdefb;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #0d47a1;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #666;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        
        .loading {
            animation: pulse 1.5s infinite;
            color: #2196f3;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ§ª ØªØ³Øª State Persistence - Vakamova</h1>
            <p>Ø³ÛŒØ³ØªÙ… Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒØŒ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ø§Ù„Øª Ù¾Ø§ÛŒØ¯Ø§Ø±</p>
        </header>
        
        <div class="test-section">
            <h2>ğŸ“Š Ø¢Ù…Ø§Ø± Ø³ÛŒØ³ØªÙ…</h2>
            <div class="stats" id="stats-container">
                <!-- Ø¢Ù…Ø§Ø± Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø§ÛŒÙ†Ø§Ù…ÛŒÚ© Ù„ÙˆØ¯ Ù…ÛŒâ€ŒØ´ÙˆØ¯ -->
            </div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ¯ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ</h2>
            <div class="control-panel">
                <button onclick="runAllTests()" id="run-all-btn">
                    <span>â–¶ï¸</span>
                    Ø§Ø¬Ø±Ø§ÛŒ ØªÙ…Ø§Ù… ØªØ³Øªâ€ŒÙ‡Ø§
                </button>
                <button onclick="runAutoSaveTest()" id="auto-save-btn">
                    <span>â±ï¸</span>
                    ØªØ³Øª Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±
                </button>
                <button onclick="clearAllData()" id="clear-btn">
                    <span>ğŸ—‘ï¸</span>
                    Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
                </button>
                <button onclick="simulateCrash()" id="crash-btn">
                    <span>âš¡</span>
                    Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Crash
                </button>
            </div>
            
            <div id="tests-container">
                <!-- ØªØ³Øªâ€ŒÙ‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø§ÛŒÙ†Ø§Ù…ÛŒÚ© Ù„ÙˆØ¯ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ -->
            </div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ’¾ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡</h2>
            <div class="timer-display">
                <span>Ø¢Ø®Ø±ÛŒÙ† Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ: <span id="last-save">--:--:--</span></span>
                <span>Ø§Ù†Ø¯Ø§Ø²Ù‡ Ø¯Ø§Ø¯Ù‡: <span id="data-size">0 KB</span></span>
            </div>
            <div class="persistence-data" id="stored-data">
                Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...
            </div>
        </div>
    </div>

    <script>
        // ====================== StatePersistenceManager ======================
        class StatePersistenceManager {
            constructor(storageKey = 'vakamova_state', autoSaveInterval = 5000) {
                this.storageKey = storageKey;
                this.autoSaveInterval = autoSaveInterval;
                this.lastSaveTime = null;
                this.saveCount = 0;
                this.loadCount = 0;
                this.autoSaveTimer = null;
                this.listeners = new Set();
                
                // Initialize
                this.stats = {
                    totalSaves: 0,
                    totalLoads: 0,
                    totalBytes: 0,
                    lastError: null,
                    recoveryAttempts: 0
                };
                
                // Load existing stats
                this.loadStats();
            }
            
            // ========== CORE METHODS ==========
            save(state, description = 'manual') {
                try {
                    const startTime = performance.now();
                    
                    // Validate state
                    if (!state || typeof state !== 'object') {
                        throw new Error('Invalid state object');
                    }
                    
                    // Serialize with metadata
                    const data = {
                        state: state,
                        metadata: {
                            version: '1.0',
                            timestamp: Date.now(),
                            description: description,
                            checksum: this._generateChecksum(state),
                            size: JSON.stringify(state).length
                        }
                    };
                    
                    // Compress if large (simulated)
                    const serialized = this._serialize(data);
                    
                    // Save to storage
                    localStorage.setItem(this.storageKey, serialized);
                    
                    // Update stats
                    const saveTime = performance.now() - startTime;
                    this.lastSaveTime = Date.now();
                    this.saveCount++;
                    this.stats.totalSaves++;
                    this.stats.totalBytes += serialized.length;
                    
                    // Notify listeners
                    this._notify('save', {
                        time: saveTime,
                        size: serialized.length,
                        description
                    });
                    
                    console.log(`âœ… State saved (${description}): ${saveTime.toFixed(2)}ms, ${serialized.length} bytes`);
                    return true;
                    
                } catch (error) {
                    this.stats.lastError = error.message;
                    console.error('âŒ Save failed:', error);
                    this._notify('error', { operation: 'save', error });
                    return false;
                }
            }
            
            load() {
                try {
                    const startTime = performance.now();
                    
                    // Load from storage
                    const serialized = localStorage.getItem(this.storageKey);
                    if (!serialized) {
                        console.log('ğŸ“­ No saved state found');
                        return null;
                    }
                    
                    // Deserialize
                    const data = this._deserialize(serialized);
                    
                    // Validate
                    if (!this._validate(data)) {
                        throw new Error('State validation failed');
                    }
                    
                    // Update stats
                    const loadTime = performance.now() - startTime;
                    this.loadCount++;
                    this.stats.totalLoads++;
                    
                    this._notify('load', {
                        time: loadTime,
                        size: serialized.length,
                        timestamp: data.metadata.timestamp
                    });
                    
                    console.log(`âœ… State loaded: ${loadTime.toFixed(2)}ms, from ${new Date(data.metadata.timestamp).toLocaleTimeString()}`);
                    return data.state;
                    
                } catch (error) {
                    this.stats.recoveryAttempts++;
                    console.error('âŒ Load failed, attempting recovery:', error);
                    
                    // Try recovery
                    const recovered = this._attemptRecovery();
                    if (recovered) {
                        console.log('ğŸ”„ State recovered from backup');
                        return recovered;
                    }
                    
                    this.stats.lastError = error.message;
                    this._notify('error', { operation: 'load', error });
                    return null;
                }
            }
            
            // ========== ADVANCED FEATURES ==========
            enableAutoSave(getStateCallback, interval = null) {
                if (this.autoSaveTimer) {
                    clearInterval(this.autoSaveTimer);
                }
                
                const saveInterval = interval || this.autoSaveInterval;
                this.autoSaveTimer = setInterval(() => {
                    const state = getStateCallback();
                    if (state) {
                        this.save(state, 'auto-save');
                    }
                }, saveInterval);
                
                console.log(`â±ï¸ Auto-save enabled every ${saveInterval}ms`);
                return true;
            }
            
            disableAutoSave() {
                if (this.autoSaveTimer) {
                    clearInterval(this.autoSaveTimer);
                    this.autoSaveTimer = null;
                    console.log('â¸ï¸ Auto-save disabled');
                }
            }
            
            createSnapshot(name) {
                try {
                    const state = this.load();
                    if (!state) return false;
                    
                    const snapshot = {
                        name,
                        state,
                        timestamp: Date.now(),
                        size: JSON.stringify(state).length
                    };
                    
                    const snapshots = this.getSnapshots();
                    snapshots.push(snapshot);
                    
                    // Keep only last 10 snapshots
                    if (snapshots.length > 10) {
                        snapshots.shift();
                    }
                    
                    localStorage.setItem(`${this.storageKey}_snapshots`, JSON.stringify(snapshots));
                    console.log(`ğŸ“¸ Snapshot created: ${name}`);
                    return true;
                    
                } catch (error) {
                    console.error('Snapshot failed:', error);
                    return false;
                }
            }
            
            getSnapshots() {
                try {
                    const data = localStorage.getItem(`${this.storageKey}_snapshots`);
                    return data ? JSON.parse(data) : [];
                } catch {
                    return [];
                }
            }
            
            restoreSnapshot(name) {
                const snapshots = this.getSnapshots();
                const snapshot = snapshots.find(s => s.name === name);
                
                if (snapshot) {
                    const success = this.save(snapshot.state, `restore-${name}`);
                    if (success) {
                        console.log(`ğŸ”„ Snapshot restored: ${name}`);
                        return snapshot.state;
                    }
                }
                
                return null;
            }
            
            clearAll() {
                try {
                    // Clear all related data
                    localStorage.removeItem(this.storageKey);
                    localStorage.removeItem(`${this.storageKey}_snapshots`);
                    localStorage.removeItem(`${this.storageKey}_stats`);
                    localStorage.removeItem(`${this.storageKey}_backup`);
                    
                    // Reset stats
                    this.saveCount = 0;
                    this.loadCount = 0;
                    this.lastSaveTime = null;
                    this.stats = {
                        totalSaves: 0,
                        totalLoads: 0,
                        totalBytes: 0,
                        lastError: null,
                        recoveryAttempts: 0
                    };
                    
                    console.log('ğŸ§¹ All persistence data cleared');
                    this._notify('clear');
                    return true;
                    
                } catch (error) {
                    console.error('Clear failed:', error);
                    return false;
                }
            }
            
            // ========== UTILITY METHODS ==========
            _serialize(data) {
                // Add compression simulation for large data
                const jsonString = JSON.stringify(data);
                if (jsonString.length > 10000) {
                    // Simulate compression
                    return btoa(jsonString); // Simple base64 encoding
                }
                return jsonString;
            }
            
            _deserialize(serialized) {
                try {
                    // Try JSON first
                    return JSON.parse(serialized);
                } catch {
                    // Try base64 decode
                    try {
                        return JSON.parse(atob(serialized));
                    } catch {
                        throw new Error('Failed to deserialize state');
                    }
                }
            }
            
            _validate(data) {
                if (!data || !data.metadata || !data.state) {
                    return false;
                }
                
                // Check checksum
                const calculatedChecksum = this._generateChecksum(data.state);
                if (data.metadata.checksum !== calculatedChecksum) {
                    console.warn('Checksum mismatch, attempting recovery');
                    return false;
                }
                
                // Check timestamp (not too old)
                const age = Date.now() - data.metadata.timestamp;
                if (age > 30 * 24 * 60 * 60 * 1000) { // 30 days
                    console.warn('State is too old');
                    return false;
                }
                
                return true;
            }
            
            _generateChecksum(obj) {
                const str = JSON.stringify(obj);
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash |= 0; // Convert to 32bit integer
                }
                return hash.toString(36);
            }
            
            _attemptRecovery() {
                try {
                    // Try backup
                    const backup = localStorage.getItem(`${this.storageKey}_backup`);
                    if (backup) {
                        const data = JSON.parse(backup);
                        if (this._validate(data)) {
                            // Restore from backup
                            localStorage.setItem(this.storageKey, backup);
                            console.log('âœ… Recovered from backup');
                            return data.state;
                        }
                    }
                    
                    // Try last known good state
                    const snapshots = this.getSnapshots();
                    if (snapshots.length > 0) {
                        const latest = snapshots[snapshots.length - 1];
                        localStorage.setItem(this.storageKey, JSON.stringify({
                            state: latest.state,
                            metadata: { ...latest, timestamp: Date.now() }
                        }));
                        console.log('âœ… Recovered from latest snapshot');
                        return latest.state;
                    }
                    
                } catch (error) {
                    console.error('Recovery failed:', error);
                }
                
                return null;
            }
            
            _notify(event, data = {}) {
                this.listeners.forEach(listener => {
                    try {
                        listener(event, data);
                    } catch (error) {
                        console.error('Listener error:', error);
                    }
                });
            }
            
            // ========== STATS MANAGEMENT ==========
            loadStats() {
                try {
                    const savedStats = localStorage.getItem(`${this.storageKey}_stats`);
                    if (savedStats) {
                        const parsed = JSON.parse(savedStats);
                        this.stats = { ...this.stats, ...parsed };
                    }
                } catch (error) {
                    console.warn('Could not load stats:', error);
                }
            }
            
            saveStats() {
                try {
                    localStorage.setItem(`${this.storageKey}_stats`, JSON.stringify(this.stats));
                } catch (error) {
                    console.warn('Could not save stats:', error);
                }
            }
            
            // ========== BACKUP SYSTEM ==========
            createBackup() {
                try {
                    const current = localStorage.getItem(this.storageKey);
                    if (current) {
                        localStorage.setItem(`${this.storageKey}_backup`, current);
                        console.log('ğŸ’¾ Backup created');
                        return true;
                    }
                } catch (error) {
                    console.error('Backup failed:', error);
                }
                return false;
            }
            
            getInfo() {
                const data = localStorage.getItem(this.storageKey);
                return {
                    exists: !!data,
                    size: data ? data.length : 0,
                    lastSave: this.lastSaveTime,
                    saveCount: this.saveCount,
                    loadCount: this.loadCount,
                    snapshots: this.getSnapshots().length,
                    stats: { ...this.stats }
                };
            }
            
            // ========== EVENT SYSTEM ==========
            on(event, callback) {
                this.listeners.add(callback);
                return () => this.listeners.delete(callback);
            }
        }

        // ====================== TEST MANAGER ======================
        const TestManager = {
            persistence: new StatePersistenceManager('vakamova_test_state', 3000),
            currentState: null,
            testResults: {},
            
            // Test definitions
            tests: [
                {
                    id: 'test-1',
                    title: 'Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡',
                    description: 'Ø°Ø®ÛŒØ±Ù‡ state Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø§ Ø³Ø§Ø®ØªØ§Ø± Ú©Ø§Ù…Ù„',
                    run: async () => {
                        const testState = {
                            user: {
                                id: 'user_001',
                                name: 'Ú©Ø§Ø±Ø¨Ø± ØªØ³Øª',
                                progress: { level: 5, points: 1250 },
                                settings: { theme: 'dark', language: 'fa' }
                            },
                            lessons: {
                                current: 'lesson_10',
                                completed: ['lesson_1', 'lesson_2', 'lesson_3'],
                                progress: 75
                            },
                            system: { version: '1.0.0', lastSync: Date.now() }
                        };
                        
                        TestManager.currentState = testState;
                        const success = TestManager.persistence.save(testState, 'initial-save');
                        
                        if (!success) throw new Error('Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯');
                        return `âœ… State Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯ (${JSON.stringify(testState).length} bytes)`;
                    }
                },
                {
                    id: 'test-2',
                    title: 'Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ùˆ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ',
                    description: 'Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ state Ùˆ Ø¨Ø±Ø±Ø³ÛŒ ØµØ­Øª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§',
                    run: async () => {
                        const loadedState = TestManager.persistence.load();
                        
                        if (!loadedState) throw new Error('Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ state Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯');
                        
                        // Deep comparison
                        const original = TestManager.currentState;
                        if (!this._deepEqual(original, loadedState)) {
                            throw new Error('Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù‡ Ø¨Ø§ Ø¯Ø§Ø¯Ù‡ Ø§ØµÙ„ÛŒ ØªØ·Ø§Ø¨Ù‚ Ù†Ø¯Ø§Ø±Ù†Ø¯');
                        }
                        
                        TestManager.currentState = loadedState;
                        return `âœ… State Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯ (Ù†Ø³Ø®Ù‡: ${loadedState.system.version})`;
                    }
                },
                {
                    id: 'test-3',
                    title: 'Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±',
                    description: 'ØªØ³Øª Ø³ÛŒØ³ØªÙ… Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Ù‡Ø± 3 Ø«Ø§Ù†ÛŒÙ‡',
                    run: async () => {
                        return new Promise((resolve) => {
                            let autoSaveCount = 0;
                            let lastState = null;
                            
                            const unsubscribe = TestManager.persistence.on('save', (event, data) => {
                                if (data.description === 'auto-save') {
                                    autoSaveCount++;
                                    lastState = data;
                                }
                            });
                            
                            // Start auto-save
                            TestManager.persistence.enableAutoSave(() => TestManager.currentState, 1000);
                            
                            // Wait for 3 auto-saves
                            setTimeout(() => {
                                TestManager.persistence.disableAutoSave();
                                unsubscribe();
                                
                                if (autoSaveCount >= 2) {
                                    resolve(`âœ… ${autoSaveCount} Ø¨Ø§Ø± Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯`);
                                } else {
                                    throw new Error(`ØªÙ†Ù‡Ø§ ${autoSaveCount} Ø¨Ø§Ø± Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯`);
                                }
                            }, 3500);
                        });
                    }
                },
                {
                    id: 'test-4',
                    title: 'Ø³ÛŒØ³ØªÙ… Snapshot',
                    description: 'Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Snapshot',
                    run: async () => {
                        // Create snapshot
                        const snapshotName = `snapshot_${Date.now()}`;
                        const success = TestManager.persistence.createSnapshot(snapshotName);
                        
                        if (!success) throw new Error('Ø§ÛŒØ¬Ø§Ø¯ Snapshot Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯');
                        
                        // Modify current state
                        const modifiedState = {
                            ...TestManager.currentState,
                            user: {
                                ...TestManager.currentState.user,
                                name: 'Ú©Ø§Ø±Ø¨Ø± ØªØºÛŒÛŒØ± ÛŒØ§ÙØªÙ‡'
                            }
                        };
                        
                        TestManager.persistence.save(modifiedState, 'after-modification');
                        
                        // Restore snapshot
                        const restored = TestManager.persistence.restoreSnapshot(snapshotName);
                        if (!restored) throw new Error('Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Snapshot Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯');
                        
                        // Verify restoration
                        if (restored.user.name !== 'Ú©Ø§Ø±Ø¨Ø± ØªØ³Øª') {
                            throw new Error('Snapshot Ø¨Ù‡ Ø¯Ø±Ø³ØªÛŒ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù†Ø´Ø¯');
                        }
                        
                        TestManager.currentState = restored;
                        return `âœ… Snapshot Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯: ${snapshotName}`;
                    }
                },
                {
                    id: 'test-5',
                    title: 'Ø³ÛŒØ³ØªÙ… Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø² Ø®Ø·Ø§',
                    description: 'Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Crash Ùˆ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ',
                    run: async () => {
                        // Create backup first
                        TestManager.persistence.createBackup();
                        
                        // Simulate corrupted data
                        localStorage.setItem('vakamova_test_state', 'CORRUPTED_DATA!!!');
                        
                        // Try to load (should trigger recovery)
                        const recoveredState = TestManager.persistence.load();
                        
                        if (!recoveredState) {
                            throw new Error('Ø³ÛŒØ³ØªÙ… Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù†ØªÙˆØ§Ù†Ø³Øª state Ø±Ø§ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ú©Ù†Ø¯');
                        }
                        
                        TestManager.currentState = recoveredState;
                        return 'âœ… Ø³ÛŒØ³ØªÙ… Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø² Ø®Ø·Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ú©Ø§Ø± Ú©Ø±Ø¯';
                    }
                },
                {
                    id: 'test-6',
                    title: 'Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ø§ÙØ¸Ù‡ Ùˆ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ',
                    description: 'Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ùˆ Ø¨Ø±Ø±Ø³ÛŒ Ø¢Ø²Ø§Ø¯Ø³Ø§Ø²ÛŒ Ø­Ø§ÙØ¸Ù‡',
                    run: async () => {
                        const beforeSize = JSON.stringify(localStorage).length;
                        
                        // Clear all
                        const success = TestManager.persistence.clearAll();
                        if (!success) throw new Error('Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯');
                        
                        const afterSize = JSON.stringify(localStorage).length;
                        const freedKB = ((beforeSize - afterSize) / 1024).toFixed(2);
                        
                        // Verify
                        const info = TestManager.persistence.getInfo();
                        if (info.exists || info.size > 0) {
                            throw new Error('Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ù‡ Ø·ÙˆØ± Ú©Ø§Ù…Ù„ Ù¾Ø§Ú© Ù†Ø´Ø¯Ù†Ø¯');
                        }
                        
                        // Re-initialize
                        TestManager.currentState = {
                            user: { id: 'new_user', name: 'Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯' },
                            system: { version: '1.0.0', lastSync: Date.now() }
                        };
                        
                        TestManager.persistence.save(TestManager.currentState, 'after-clear');
                        
                        return `âœ… Ø­Ø§ÙØ¸Ù‡ Ù¾Ø§Ú© Ø´Ø¯ (${freedKB} KB Ø¢Ø²Ø§Ø¯ Ø´Ø¯)`;
                    }
                },
                {
                    id: 'test-7',
                    title: 'ØªØ³Øª Ú©Ø§Ø±Ø§ÛŒÛŒ Ùˆ Performance',
                    description: 'Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø­Ø¬ÛŒÙ…',
                    run: async () => {
                        // Create large state (simulate 1000 lessons)
                        const largeState = {
                            user: { id: 'perf_user', name: 'Ú©Ø§Ø±Ø¨Ø± Ú©Ø§Ø±Ø§ÛŒÛŒ' },
                            lessons: {},
                            timestamp: Date.now()
                        };
                        
                        // Add 1000 fake lessons
                        for (let i = 0; i < 1000; i++) {
                            largeState.lessons[`lesson_${i}`] = {
                                id: `lesson_${i}`,
                                title: `Ø¯Ø±Ø³ ${i}`,
                                completed: Math.random() > 0.5,
                                score: Math.floor(Math.random() * 100),
                                timeSpent: Math.floor(Math.random() * 3600)
                            };
                        }
                        
                        const startTime = performance.now();
                        const success = TestManager.persistence.save(largeState, 'large-data-test');
                        const saveTime = performance.now() - startTime;
                        
                        if (!success) throw new Error('Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡ Ø­Ø¬ÛŒÙ… Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯');
                        
                        const size = JSON.stringify(largeState).length;
                        const sizeKB = (size / 1024).toFixed(2);
                        
                        return `âœ… ${sizeKB} KB Ø¯Ø± ${saveTime.toFixed(2)}ms Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯ (${(size/saveTime/1024).toFixed(2)} MB/s)`;
                    }
                }
            ],
            
            // Helper methods
            _deepEqual(obj1, obj2) {
                return JSON.stringify(obj1) === JSON.stringify(obj2);
            },
            
            // UI Methods
            renderTests() {
                const container = document.getElementById('tests-container');
                container.innerHTML = '<div class="test-grid" id="test-grid"></div>';
                
                const grid = document.getElementById('test-grid');
                this.tests.forEach(test => {
                    const card = document.createElement('div');
                    card.className = 'test-card';
                    card.id = `card-${test.id}`;
                    card.innerHTML = `
                        <div class="test-title">
                            <span>${test.title}</span>
                            <span class="test-status status-running" id="status-${test.id}">Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±</span>
                        </div>
                        <div class="test-desc">${test.description}</div>
                        <div class="test-output" id="output-${test.id}"></div>
                    `;
                    grid.appendChild(card);
                });
            },
            
            async runTest(test) {
                const card = document.getElementById(`card-${test.id}`);
                const status = document.getElementById(`status-${test.id}`);
                const output = document.getElementById(`output-${test.id}`);
                
                card.style.borderColor = '#ff9800';
                status.className = 'test-status status-running';
                status.textContent = 'Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§...';
                output.innerHTML = '<span class="loading">ğŸ”„ Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øª...</span>';
                
                try {
                    const result = await test.run();
                    card.style.borderColor = '#4caf50';
                    status.className = 'test-status status-success';
                    status.textContent = 'Ù…ÙˆÙÙ‚';
                    output.innerHTML = result;
                    this.testResults[test.id] = { success: true, result };
                    return true;
                } catch (error) {
                    card.style.borderColor = '#f44336';
                    status.className = 'test-status status-error';
                    status.textContent = 'Ù†Ø§Ù…ÙˆÙÙ‚';
                    output.innerHTML = `<strong>âŒ Ø®Ø·Ø§:</strong> ${error.message}`;
                    this.testResults[test.id] = { success: false, error: error.message };
                    return false;
                }
            },
            
            async runAllTests() {
                const btn = document.getElementById('run-all-btn');
                btn.disabled = true;
                btn.innerHTML = '<span class="loading">ğŸ”„</span> Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§...';
                
                let passed = 0;
                for (const test of this.tests) {
                    const success = await this.runTest(test);
                    if (success) passed++;
                    await new Promise(resolve => setTimeout(resolve, 500)); // Delay for visibility
                }
                
                btn.disabled = false;
                btn.innerHTML = '<span>â–¶ï¸</span> Ø§Ø¬Ø±Ø§ÛŒ Ù…Ø¬Ø¯Ø¯ ØªÙ…Ø§Ù… ØªØ³Øªâ€ŒÙ‡Ø§';
                
                // Update stats
                this.updateStats();
                this.updateDisplay();
                
                console.log(`ğŸ¯ ØªØ³Øªâ€ŒÙ‡Ø§ Ú©Ø§Ù…Ù„ Ø´Ø¯: ${passed} Ø§Ø² ${this.tests.length} Ù…ÙˆÙÙ‚`);
            },
            
            updateStats() {
                const statsContainer = document.getElementById('stats-container');
                const info = this.persistence.getInfo();
                
                statsContainer.innerHTML = `
                    <div class="stat-box">
                        <div class="stat-value">${info.saveCount}</div>
                        <div class="stat-label">ØªØ¹Ø¯Ø§Ø¯ Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">${info.loadCount}</div>
                        <div class="stat-label">ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">${(info.size / 1024).toFixed(2)}</div>
                        <div class="stat-label">Ø­Ø¬Ù… (KB)</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">${info.snapshots}</div>
                        <div class="stat-label">SnapshotÙ‡Ø§</div>
                    </div>
                `;
            },
            
            updateDisplay() {
                // Update last save time
                const lastSaveEl = document.getElementById('last-save');
                lastSaveEl.textContent = this.persistence.lastSaveTime 
                    ? new Date(this.persistence.lastSaveTime).toLocaleTimeString('fa-IR')
                    : '--:--:--';
                
                // Update data size
                const dataSizeEl = document.getElementById('data-size');
                const info = this.persistence.getInfo();
                dataSizeEl.textContent = `${(info.size / 1024).toFixed(2)} KB`;
                
                // Update stored data preview
                const storedDataEl = document.getElementById('stored-data');
                try {
                    const state = this.persistence.load();
                    storedDataEl.innerHTML = `<pre>${JSON.stringify(state, null, 2)}</pre>`;
                } catch {
                    storedDataEl.textContent = 'Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯';
                }
            },
            
            runAutoSaveTest() {
                const btn = document.getElementById('auto-save-btn');
                btn.disabled = true;
                btn.innerHTML = '<span class="loading">â±ï¸</span> Ø¯Ø± Ø­Ø§Ù„ ØªØ³Øª...';
                
                let changesCount = 0;
                const unsubscribe = this.persistence.on('save', (event, data) => {
                    if (data.description === 'auto-save') {
                        changesCount++;
                        this.updateDisplay();
                    }
                });
                
                // Enable auto-save with fast interval for demo
                this.persistence.enableAutoSave(() => this.currentState, 800);
                
                // Simulate state changes
                const changeInterval = setInterval(() => {
                    if (!this.currentState) return;
                    
                    this.currentState = {
                        ...this.currentState,
                        system: {
                            ...this.currentState.system,
                            lastSync: Date.now(),
                            changeCount: changesCount
                        }
                    };
                    
                }, 1000);
                
                // Stop after 5 seconds
                setTimeout(() => {
                    clearInterval(changeInterval);
                    this.persistence.disableAutoSave();
                    unsubscribe();
                    
                    btn.disabled = false;
                    btn.innerHTML = '<span>â±ï¸</span> ØªØ³Øª Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±';
                    
                    alert(`Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±: ${changesCount} ØªØºÛŒÛŒØ± Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯`);
                    
                }, 5000);
            },
            
            clearAllData() {
                if (confirm('Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù†ÛŒØ¯ØŸ ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡ Ù¾Ø§Ú© Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.')) {
                    this.persistence.clearAll();
                    this.currentState = null;
                    this.updateStats();
                    this.updateDisplay();
                    this.renderTests();
                    alert('âœ… ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ù¾Ø§Ú© Ø´Ø¯Ù†Ø¯');
                }
            },
            
            simulateCrash() {
                // Simulate power failure during save
                const originalState = this.currentState;
                
                // Start save
                this.persistence.save(originalState, 'before-crash');
                
                // Simulate crash (corrupt data)
                setTimeout(() => {
                    localStorage.setItem('vakamova_test_state', 'CRASH_SIMULATION_INCOMPLETE_SAVE{');
                    
                    // Try to recover
                    const recovered = this.persistence.load();
                    if (recovered) {
                        this.currentState = recovered;
                        this.updateDisplay();
                        alert('âœ… Ø³ÛŒØ³ØªÙ… Crash Recovery Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ú©Ø§Ø± Ú©Ø±Ø¯! State Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯.');
                    } else {
                        alert('âš ï¸ Crash Recovery Ù†ØªÙˆØ§Ù†Ø³Øª state Ø±Ø§ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ú©Ù†Ø¯');
                    }
                }, 100);
            }
        };

        // ====================== INITIALIZATION ======================
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize
            TestManager.renderTests();
            TestManager.updateStats();
            TestManager.updateDisplay();
            
            // Set up periodic updates
            setInterval(() => {
                TestManager.updateDisplay();
            }, 2000);
            
            // Save stats periodically
            setInterval(() => {
                TestManager.persistence.saveStats();
            }, 10000);
            
            console.log('ğŸš€ State Persistence Test Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª');
            console.log('ğŸ“± ØªÙ…Ø§Ù… ØªØ³Øªâ€ŒÙ‡Ø§ Ø¯Ø± Ù…Ø±ÙˆØ±Ú¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ Ù‚Ø§Ø¨Ù„ Ø§Ø¬Ø±Ø§ Ù‡Ø³ØªÙ†Ø¯');
        });

        // ====================== GLOBAL FUNCTIONS ======================
        window.runAllTests = () => TestManager.runAllTests();
        window.runAutoSaveTest = () => TestManager.runAutoSaveTest();
        window.clearAllData = () => TestManager.clearAllData();
        window.simulateCrash = () => TestManager.simulateCrash();
    </script>
</body>
</html>
