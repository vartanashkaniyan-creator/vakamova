<!DOCTYPE html>
<html dir="rtl" lang="fa">
<head>
    <meta charset="UTF-8">
    <title>ØªØ³Øª Performance - Vakamova</title>
    <style>
        body { font-family: Tahoma; max-width: 1200px; margin: 20px auto; padding: 20px; background: #f8f9fa; }
        .performance-card { background: white; padding: 20px; margin: 15px 0; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.08); }
        .metric { display: inline-block; margin: 10px 15px; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; min-width: 150px; text-align: center; }
        .good { background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%) !important; }
        .warning { background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%) !important; }
        .critical { background: linear-gradient(135deg, #F44336 0%, #C62828 100%) !important; }
        button { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; border: none; padding: 14px 28px; border-radius: 8px; cursor: pointer; font-size: 16px; margin: 10px 5px; font-weight: bold; }
        .chart-container { height: 200px; margin: 20px 0; background: #f5f5f5; border-radius: 8px; padding: 15px; }
        .progress-bar { height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden; margin: 10px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <h1>âš¡ ØªØ³Øª Performance Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Vakamova</h1>
    <p>Ø¨Ø±Ø±Ø³ÛŒ Ø³Ø±Ø¹ØªØŒ Ù…ØµØ±Ù Ø­Ø§ÙØ¸Ù‡ Ùˆ Ú©Ø§Ø±Ø§ÛŒÛŒ Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ</p>
    
    <div class="performance-card">
        <h3>ğŸ¯ Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ÛŒ ØªØ­Øª ØªØ³Øª</h3>
        <div class="metric">ExerciseManager</div>
        <div class="metric">UserProfileManager</div>
        <div class="metric">APIClient</div>
        <div class="metric">State Manager</div>
    </div>
    
    <button onclick="runAllPerformanceTests()">Ø´Ø±ÙˆØ¹ ØªØ³Øª Ú©Ø§Ù…Ù„ Performance</button>
    <button onclick="runQuickPerformanceTest()">ØªØ³Øª Ø³Ø±ÛŒØ¹ Performance</button>
    <button onclick="runMemoryTest()">ØªØ³Øª Ù…ØµØ±Ù Ø­Ø§ÙØ¸Ù‡</button>
    
    <div id="results"></div>
    <div id="charts"></div>

    <script>
        // ==================== Performance Test Framework ====================
        class PerformanceTester {
            constructor() {
                this.results = [];
                this.charts = [];
                this.memorySamples = [];
                this.startTime = null;
            }
            
            startMeasurement(name) {
                return {
                    name,
                    startTime: performance.now(),
                    startMemory: this.getMemoryUsage()
                };
            }
            
            endMeasurement(measurement) {
                const endTime = performance.now();
                const endMemory = this.getMemoryUsage();
                
                const duration = endTime - measurement.startTime;
                const memoryDiff = endMemory.usedJSHeapSize - measurement.startMemory.usedJSHeapSize;
                
                return {
                    name: measurement.name,
                    duration: Math.round(duration * 100) / 100, // ms
                    memoryChange: Math.round(memoryDiff / 1024), // KB
                    timestamp: new Date().toISOString()
                };
            }
            
            getMemoryUsage() {
                if (performance.memory) {
                    return {
                        usedJSHeapSize: performance.memory.usedJSHeapSize,
                        totalJSHeapSize: performance.memory.totalJSHeapSize,
                        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
                    };
                }
                return { usedJSHeapSize: 0, totalJSHeapSize: 0, jsHeapSizeLimit: 0 };
            }
            
            addResult(result) {
                this.results.push(result);
                
                // ØªØ¹ÛŒÛŒÙ† ÙˆØ¶Ø¹ÛŒØª Ø¨Ø± Ø§Ø³Ø§Ø³ Ø²Ù…Ø§Ù† Ø§Ø¬Ø±Ø§
                let status = 'good';
                if (result.duration > 100) status = 'warning';
                if (result.duration > 500) status = 'critical';
                
                result.status = status;
                return result;
            }
            
            benchmark(iterations, operationName, operation) {
                const times = [];
                const memory = [];
                
                // Ú¯Ø±Ù… Ú©Ø±Ø¯Ù† (Warm-up)
                for (let i = 0; i < Math.min(10, iterations); i++) {
                    operation(i);
                }
                
                // Ø§Ø¬Ø±Ø§ÛŒ Ø§ØµÙ„ÛŒ
                for (let i = 0; i < iterations; i++) {
                    const start = performance.now();
                    const startMem = this.getMemoryUsage();
                    
                    operation(i);
                    
                    const end = performance.now();
                    const endMem = this.getMemoryUsage();
                    
                    times.push(end - start);
                    memory.push(endMem.usedJSHeapSize - startMem.usedJSHeapSize);
                }
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¢Ù…Ø§Ø±
                const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
                const maxTime = Math.max(...times);
                const minTime = Math.min(...times);
                const avgMemory = memory.reduce((a, b) => a + b, 0) / memory.length;
                
                return {
                    name: operationName,
                    iterations,
                    avgTime: Math.round(avgTime * 100) / 100,
                    maxTime: Math.round(maxTime * 100) / 100,
                    minTime: Math.round(minTime * 100) / 100,
                    opsPerSecond: Math.round(1000 / avgTime),
                    avgMemory: Math.round(avgMemory / 1024),
                    times,
                    memorySamples: memory
                };
            }
            
            generateReport() {
                const report = {
                    totalTests: this.results.length,
                    totalTime: this.results.reduce((sum, r) => sum + r.duration, 0),
                    averageTime: this.results.reduce((sum, r) => sum + r.duration, 0) / this.results.length,
                    byStatus: this.results.reduce((acc, r) => {
                        acc[r.status] = (acc[r.status] || 0) + 1;
                        return acc;
                    }, {}),
                    details: this.results
                };
                
                return report;
            }
        }
        
        // ==================== Mock Data Generators ====================
        class MockDataGenerator {
            static generateExercises(count) {
                const exercises = [];
                const types = ['multipleChoice', 'fillBlank', 'matching', 'pronunciation'];
                
                for (let i = 0; i < count; i++) {
                    exercises.push({
                        id: `ex_${i}`,
                        type: types[i % types.length],
                        question: `Ø³ÙˆØ§Ù„ ØªØ³Øª ${i + 1} Ø¯Ø± Ù…ÙˆØ±Ø¯ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ø²Ø¨Ø§Ù†`,
                        options: ['Ú¯Ø²ÛŒÙ†Ù‡ Û±', 'Ú¯Ø²ÛŒÙ†Ù‡ Û²', 'Ú¯Ø²ÛŒÙ†Ù‡ Û³', 'Ú¯Ø²ÛŒÙ†Ù‡ Û´'],
                        correctAnswer: 'Ú¯Ø²ÛŒÙ†Ù‡ ' + ((i % 4) + 1),
                        difficulty: i % 3 === 0 ? 'easy' : i % 3 === 1 ? 'medium' : 'hard',
                        lessonId: `lesson_${Math.floor(i / 10)}`,
                        createdAt: new Date().toISOString()
                    });
                }
                
                return exercises;
            }
            
            static generateUserProfiles(count) {
                const profiles = [];
                const languages = ['en', 'fa', 'es', 'fr', 'de', 'zh', 'ar', 'ru'];
                
                for (let i = 0; i < count; i++) {
                    profiles.push({
                        id: `user_${i}`,
                        fullName: `Ú©Ø§Ø±Ø¨Ø± ØªØ³Øª ${i + 1}`,
                        email: `user${i}@test.com`,
                        profileImage: `https://api.dicebear.com/7.x/avataaars/svg?seed=${i}`,
                        country: i % 2 === 0 ? 'IR' : 'US',
                        timezone: 'Asia/Tehran',
                        joinDate: new Date(Date.now() - i * 86400000).toISOString(),
                        lastSeen: new Date().toISOString(),
                        languages: languages.slice(0, (i % 3) + 2).map(code => ({
                            code,
                            level: ['beginner', 'intermediate', 'advanced'][i % 3],
                            progress: Math.floor(Math.random() * 100),
                            totalMinutes: Math.floor(Math.random() * 1000)
                        })),
                        subscription: {
                            type: i % 4 === 0 ? 'free' : 'premium',
                            expiryDate: i % 4 === 0 ? null : new Date(Date.now() + 86400000 * 30).toISOString()
                        }
                    });
                }
                
                return profiles;
            }
            
            static generateAPIRequests(count) {
                const requests = [];
                const endpoints = [
                    '/lessons',
                    '/exercises',
                    '/profile',
                    '/progress',
                    '/languages'
                ];
                
                for (let i = 0; i < count; i++) {
                    requests.push({
                        method: i % 4 === 0 ? 'GET' : i % 4 === 1 ? 'POST' : i % 4 === 2 ? 'PUT' : 'DELETE',
                        endpoint: endpoints[i % endpoints.length],
                        data: i % 3 !== 0 ? { test: 'data', index: i } : null,
                        headers: {
                            'Authorization': `Bearer token_${i}`,
                            'Content-Type': 'application/json'
                        }
                    });
                }
                
                return requests;
            }
        }
        
        // ==================== Performance Tests ====================
        class ExerciseManagerPerformanceTest {
            constructor() {
                this.exercises = MockDataGenerator.generateExercises(1000);
                this.results = [];
            }
            
            testExerciseCreation(count = 100) {
                const testExercises = this.exercises.slice(0, count);
                let created = 0;
                
                const result = perfTester.benchmark(count, 'Ø§ÛŒØ¬Ø§Ø¯ ØªÙ…Ø±ÛŒÙ†', (i) => {
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø§ÛŒØ¬Ø§Ø¯ ØªÙ…Ø±ÛŒÙ†
                    const exercise = testExercises[i % testExercises.length];
                    const mockExercise = {
                        ...exercise,
                        id: `new_ex_${created++}`,
                        createdAt: new Date().toISOString()
                    };
                    return mockExercise;
                });
                
                this.results.push(result);
                return result;
            }
            
            testExerciseEvaluation(count = 100) {
                const testExercises = this.exercises.slice(0, count);
                
                const result = perfTester.benchmark(count, 'Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ ØªÙ…Ø±ÛŒÙ†', (i) => {
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ
                    const exercise = testExercises[i % testExercises.length];
                    const userAnswer = exercise.options[i % exercise.options.length];
                    const isCorrect = userAnswer === exercise.correctAnswer;
                    
                    return {
                        exerciseId: exercise.id,
                        userAnswer,
                        isCorrect,
                        score: isCorrect ? 100 : 0,
                        timestamp: new Date().toISOString()
                    };
                });
                
                this.results.push(result);
                return result;
            }
            
            testBulkOperations(count = 50) {
                const result = perfTester.benchmark(count, 'Ø¹Ù…Ù„ÛŒØ§Øª Ø¯Ø³ØªÙ‡â€ŒØ§ÛŒ ØªÙ…Ø±ÛŒÙ†', (i) => {
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø¹Ù…Ù„ÛŒØ§Øª Ø¯Ø³ØªÙ‡â€ŒØ§ÛŒ
                    const batchSize = 20;
                    const batch = [];
                    
                    for (let j = 0; j < batchSize; j++) {
                        const exIndex = (i * batchSize + j) % this.exercises.length;
                        batch.push({
                            ...this.exercises[exIndex],
                            status: 'processed',
                            order: j
                        });
                    }
                    
                    return batch;
                });
                
                this.results.push(result);
                return result;
            }
        }
        
        class UserProfilePerformanceTest {
            constructor() {
                this.profiles = MockDataGenerator.generateUserProfiles(500);
                this.results = [];
            }
            
            testProfileLoading(count = 100) {
                const result = perfTester.benchmark(count, 'Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„', (i) => {
                    const profile = this.profiles[i % this.profiles.length];
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾Ø±ÙˆÙØ§ÛŒÙ„
                    const processed = {
                        ...profile,
                        displayName: profile.fullName.toUpperCase(),
                        languageCount: profile.languages.length,
                        isPremium: profile.subscription.type === 'premium',
                        lastSeenFormatted: new Date(profile.lastSeen).toLocaleDateString('fa-IR')
                    };
                    
                    return processed;
                });
                
                this.results.push(result);
                return result;
            }
            
            testProfileSync(count = 50) {
                const result = perfTester.benchmark(count, 'Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„', (i) => {
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ
                    const profile = this.profiles[i % this.profiles.length];
                    const serverVersion = { ...profile, version: Math.floor(Math.random() * 10) };
                    const localVersion = { ...profile, version: Math.floor(Math.random() * 10) };
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… Ø§Ø¯ØºØ§Ù…
                    const merged = {
                        ...localVersion,
                        ...serverVersion,
                        lastSynced: new Date().toISOString(),
                        syncMethod: serverVersion.version > localVersion.version ? 'server' : 'local'
                    };
                    
                    return merged;
                });
                
                this.results.push(result);
                return result;
            }
            
            testSearchProfiles(count = 20) {
                const result = perfTester.benchmark(count, 'Ø¬Ø³ØªØ¬ÙˆÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„', (i) => {
                    const searchTerm = `Ú©Ø§Ø±Ø¨Ø± ${i % 10}`;
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø¬Ø³ØªØ¬ÙˆÛŒ Ø®Ø·ÛŒ (Ø¨Ø±Ø§ÛŒ ØªØ³Øª ÙØ´Ø§Ø±)
                    const results = [];
                    for (const profile of this.profiles) {
                        if (profile.fullName.includes(searchTerm) || 
                            profile.email.includes(searchTerm)) {
                            results.push(profile);
                        }
                        if (results.length >= 10) break;
                    }
                    
                    return results;
                });
                
                this.results.push(result);
                return result;
            }
        }
        
        class APIClientPerformanceTest {
            constructor() {
                this.requests = MockDataGenerator.generateAPIRequests(200);
                this.cache = new Map();
                this.results = [];
            }
            
            testRequestProcessing(count = 100) {
                const result = perfTester.benchmark(count, 'Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø±Ø®ÙˆØ§Ø³Øª API', (i) => {
                    const request = this.requests[i % this.requests.length];
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø±Ø®ÙˆØ§Ø³Øª
                    const processed = {
                        ...request,
                        timestamp: new Date().toISOString(),
                        requestId: `req_${Date.now()}_${i}`,
                        headersProcessed: Object.keys(request.headers || {}).length
                    };
                    
                    return processed;
                });
                
                this.results.push(result);
                return result;
            }
            
            testCachePerformance(count = 100) {
                // Ù¾Ø± Ú©Ø±Ø¯Ù† Ú©Ø´
                for (let i = 0; i < 100; i++) {
                    this.cache.set(`key_${i}`, {
                        data: { id: i, value: `value_${i}` },
                        expiry: Date.now() + 60000
                    });
                }
                
                const result = perfTester.benchmark(count, 'Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ú©Ø´', (i) => {
                    const key = `key_${i % 100}`;
                    const cached = this.cache.get(key);
                    
                    if (cached && cached.expiry > Date.now()) {
                        return cached.data;
                    }
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ fetch Ø¬Ø¯ÛŒØ¯
                    const newData = { id: i, value: `new_value_${i}`, fetchedAt: new Date().toISOString() };
                    this.cache.set(key, {
                        data: newData,
                        expiry: Date.now() + 60000
                    });
                    
                    return newData;
                });
                
                this.results.push(result);
                return result;
            }
            
            testBatchRequests(count = 20) {
                const result = perfTester.benchmark(count, 'Ø¯Ø±Ø®ÙˆØ§Ø³Øªâ€ŒÙ‡Ø§ÛŒ Ø¯Ø³ØªÙ‡â€ŒØ§ÛŒ', (i) => {
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ûµ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù‡Ù…Ø²Ù…Ø§Ù†
                    const batchSize = 5;
                    const batchResults = [];
                    
                    for (let j = 0; j < batchSize; j++) {
                        const reqIndex = (i * batchSize + j) % this.requests.length;
                        const request = this.requests[reqIndex];
                        
                        batchResults.push({
                            ...request,
                            responseTime: Math.random() * 100 + 50, // ms
                            success: Math.random() > 0.1,
                            processedAt: new Date().toISOString()
                        });
                    }
                    
                    return batchResults;
                });
                
                this.results.push(result);
                return result;
            }
        }
        
        // ==================== Memory Test ====================
        class MemoryUsageTest {
            constructor() {
                this.dataStructures = [];
                this.results = [];
            }
            
            testMemoryAllocation(count = 100) {
                const result = perfTester.benchmark(count, 'ØªØ®ØµÛŒØµ Ø­Ø§ÙØ¸Ù‡', (i) => {
                    // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ø§Ø®ØªØ§Ø± Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
                    const largeArray = new Array(1000).fill(null).map((_, idx) => ({
                        id: idx,
                        name: `Item ${idx}`,
                        data: new Array(10).fill('x').join(''),
                        timestamp: new Date().toISOString()
                    }));
                    
                    const largeObject = {};
                    for (let j = 0; j < 100; j++) {
                        largeObject[`key_${j}`] = {
                            value: `value_${j}_${i}`,
                            nested: { level: 2, data: 'test'.repeat(10) }
                        };
                    }
                    
                    const buffer = new ArrayBuffer(1024 * 10); // 10KB
                    
                    // Ø°Ø®ÛŒØ±Ù‡ Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² garbage collection
                    this.dataStructures.push({ largeArray, largeObject, buffer });
                    
                    // Ø­ÙØ¸ ÙÙ‚Ø· Û±Û° Ù†Ù…ÙˆÙ†Ù‡ Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² overflow Ø­Ø§ÙØ¸Ù‡
                    if (this.dataStructures.length > 10) {
                        this.dataStructures.shift();
                    }
                    
                    return { size: largeArray.length + Object.keys(largeObject).length };
                });
                
                this.results.push(result);
                return result;
            }
            
            testGarbageCollection(count = 50) {
                const result = perfTester.benchmark(count, 'ØªØ³Øª Garbage Collection', (i) => {
                    // Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø­Ø°Ù Ø§Ø´ÛŒØ§Ø¡ Ø¨Ø²Ø±Ú¯
                    const tempObjects = [];
                    
                    // Ø§ÛŒØ¬Ø§Ø¯ Û±Û°Û° Ø´ÛŒØ¡
                    for (let j = 0; j < 100; j++) {
                        tempObjects.push({
                            id: `temp_${i}_${j}`,
                            data: new Array(100).fill('data').join(''),
                            metadata: { created: Date.now(), index: j }
                        });
                    }
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´
                    const processed = tempObjects.map(obj => ({
                        ...obj,
                        processed: true,
                        hash: obj.id.split('_').reduce((sum, part) => sum + part.length, 0)
                    }));
                    
                    // Ø±Ù‡Ø§ Ú©Ø±Ø¯Ù† reference - Ø§Ø¬Ø§Ø²Ù‡ garbage collection
                    return processed.length; // ÙÙ‚Ø· Ø·ÙˆÙ„ Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯
                });
                
                this.results.push(result);
                return result;
            }
        }
        
        // ==================== Global State ====================
        const perfTester = new PerformanceTester();
        let allTestResults = [];
        
        // ==================== UI Functions ====================
        
        async function runAllPerformanceTests() {
            const resultsDiv = document.getElementById('results');
            const chartsDiv = document.getElementById('charts');
            
            resultsDiv.innerHTML = '<h2>âš¡ Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Performance...</h2>';
            chartsDiv.innerHTML = '';
            
            allTestResults = [];
            const startTime = performance.now();
            
            try {
                // ØªØ³Øª ExerciseManager
                resultsDiv.innerHTML += '<h3>ğŸ§ª ExerciseManager Performance Tests</h3>';
                const exerciseTest = new ExerciseManagerPerformanceTest();
                
                const exCreateResult = exerciseTest.testExerciseCreation(200);
                displayResult(exCreateResult);
                
                const exEvalResult = exerciseTest.testExerciseEvaluation(200);
                displayResult(exEvalResult);
                
                const exBulkResult = exerciseTest.testBulkOperations(50);
                displayResult(exBulkResult);
                
                // ØªØ³Øª UserProfileManager
                resultsDiv.innerHTML += '<h3>ğŸ‘¤ UserProfileManager Performance Tests</h3>';
                const profileTest = new UserProfilePerformanceTest();
                
                const profileLoadResult = profileTest.testProfileLoading(200);
                displayResult(profileLoadResult);
                
                const profileSyncResult = profileTest.testProfileSync(100);
                displayResult(profileSyncResult);
                
                const profileSearchResult = profileTest.testSearchProfiles(50);
                displayResult(profileSearchResult);
                
                // ØªØ³Øª APIClient
                resultsDiv.innerHTML += '<h3>ğŸŒ APIClient Performance Tests</h3>';
                const apiTest = new APIClientPerformanceTest();
                
                const apiRequestResult = apiTest.testRequestProcessing(200);
                displayResult(apiRequestResult);
                
                const apiCacheResult = apiTest.testCachePerformance(200);
                displayResult(apiCacheResult);
                
                const apiBatchResult = apiTest.testBatchRequests(50);
                displayResult(apiBatchResult);
                
                // Ø¬Ù…Ø¹â€ŒØ¨Ù†Ø¯ÛŒ
                const totalTime = performance.now() - startTime;
                
                resultsDiv.innerHTML += `
                    <div class="performance-card">
                        <h3>ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ù†Ù‡Ø§ÛŒÛŒ Performance</h3>
                        <div class="metric good">Ø²Ù…Ø§Ù† Ú©Ù„: ${Math.round(totalTime)}ms</div>
                        <div class="metric good">ØªØ¹Ø¯Ø§Ø¯ ØªØ³Øªâ€ŒÙ‡Ø§: ${allTestResults.length}</div>
                        <div class="metric good">Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø²Ù…Ø§Ù†: ${Math.round(allTestResults.reduce((sum, r) => sum + r.avgTime, 0) / allTestResults.length)}ms</div>
                        <div class="metric good">Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† OPS: ${Math.round(allTestResults.reduce((sum, r) => sum + r.opsPerSecond, 0) / allTestResults.length)}/Ø«Ø§Ù†ÛŒÙ‡</div>
                    </div>
                `;
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ù†Ù…ÙˆØ¯Ø§Ø±
                createPerformanceChart();
                
            } catch (error) {
                resultsDiv.innerHTML += `<div class="error">âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øª: ${error.message}</div>`;
                console.error(error);
            }
        }
        
        async function runQuickPerformanceTest() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<h2>âš¡ ØªØ³Øª Ø³Ø±ÛŒØ¹ Performance</h2>';
            
            allTestResults = [];
            
            // ÙÙ‚Ø· ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø³Ø±ÛŒØ¹
            const exerciseTest = new ExerciseManagerPerformanceTest();
            const exResult = exerciseTest.testExerciseCreation(50);
            displayResult(exResult);
            
            const profileTest = new UserProfilePerformanceTest();
            const profileResult = profileTest.testProfileLoading(50);
            displayResult(profileResult);
            
            const apiTest = new APIClientPerformanceTest();
            const apiResult = apiTest.testCachePerformance(50);
            displayResult(apiResult);
        }
        
        async function runMemoryTest() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<h2>ğŸ’¾ ØªØ³Øª Ù…ØµØ±Ù Ø­Ø§ÙØ¸Ù‡</h2>';
            
            const memoryTest = new MemoryUsageTest();
            
            const allocResult = memoryTest.testMemoryAllocation(20);
            displayResult(allocResult);
            
            const gcResult = memoryTest.testGarbageCollection(20);
            displayResult(gcResult);
            
            // Ù†Ù…Ø§ÛŒØ´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø­Ø§ÙØ¸Ù‡
            if (performance.memory) {
                const memInfo = performance.memory;
                resultsDiv.innerHTML += `
                    <div class="performance-card">
                        <h3>ğŸ“ˆ ÙˆØ¶Ø¹ÛŒØª Ø­Ø§ÙØ¸Ù‡ Ù…Ø±ÙˆØ±Ú¯Ø±</h3>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${(memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit) * 100}%"></div>
                        </div>
                        <p>Ù…ØµØ±Ù Ø´Ø¯Ù‡: ${Math.round(memInfo.usedJSHeapSize / 1024 / 1024)}MB / 
                           Ú©Ù„: ${Math.round(memInfo.totalJSHeapSize / 1024 / 1024)}MB /
                           Ù…Ø­Ø¯ÙˆØ¯ÛŒØª: ${Math.round(memInfo.jsHeapSizeLimit / 1024 / 1024)}MB</p>
                    </div>
                `;
            }
        }
        
        function displayResult(result) {
            allTestResults.push(result);
            
            const resultsDiv = document.getElementById('results');
            const statusClass = result.avgTime < 10 ? 'good' : result.avgTime < 50 ? 'warning' : 'critical';
            
            resultsDiv.innerHTML += `
                <div class="performance-card">
                    <h4>${result.name}</h4>
                    <div class="metric ${statusClass}">Ù…ÛŒØ§Ù†Ú¯ÛŒÙ†: ${result.avgTime}ms</div>
                    <div class="metric">Ù…Ø§Ú©Ø²ÛŒÙ…Ù…: ${result.maxTime}ms</div>
                    <div class="metric">Ù…ÛŒÙ†ÛŒÙ…Ù…: ${result.minTime}ms</div>
                    <div class="metric ${result.opsPerSecond > 100 ? 'good' : 'warning'}">${result.opsPerSecond}/Ø«Ø§Ù†ÛŒÙ‡</div>
                    <div class="metric">Ø­Ø§ÙØ¸Ù‡: ${result.avgMemory || 0}KB</div>
                    <p>ØªØ¹Ø¯Ø§Ø¯ ØªÚ©Ø±Ø§Ø±: ${result.iterations}</p>
                </div>
            `;
        }
        
        function createPerformanceChart() {
            const chartsDiv = document.getElementById('charts');
            chartsDiv.innerHTML = '<h3>ğŸ“Š Ù†Ù…ÙˆØ¯Ø§Ø± Performance</h3>';
            
            const canvas = document.createElement('canvas');
            canvas.id = 'performanceChart';
            canvas.width = 800;
            canvas.height = 400;
            chartsDiv.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            
            const labels = allTestResults.map(r => r.name.substring(0, 20) + '...');
            const avgTimes = allTestResults.map(r => r.avgTime);
            const opsPerSecond = allTestResults.map(r => r.opsPerSecond);
            
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø²Ù…Ø§Ù† (ms)',
                            data: avgTimes,
                            backgroundColor: 'rgba(54, 162, 235, 0.6)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ø± Ø«Ø§Ù†ÛŒÙ‡',
                            data: opsPerSecond,
                            backgroundColor: 'rgba(75, 192, 192, 0.6)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1,
                            type: 'line',
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Ø²Ù…Ø§Ù† (Ù…ÛŒÙ„ÛŒâ€ŒØ«Ø§Ù†ÛŒÙ‡)'
                            }
                        },
                        y1: {
                            position: 'right',
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ø± Ø«Ø§Ù†ÛŒÙ‡'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        title: {
                            display: true,
                            text: 'Ù…Ù‚Ø§ÛŒØ³Ù‡ Performance Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§'
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>
