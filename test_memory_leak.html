<!DOCTYPE html>
<html dir="rtl" lang="fa">
<head>
    <meta charset="UTF-8">
    <title>ØªØ³Øª Ù†Ø´Øª Ø­Ø§ÙØ¸Ù‡ - Vakamova</title>
    <style>
        body { font-family: Tahoma; padding: 20px; background: #0a192f; color: #ccd6f6; }
        .container { max-width: 1200px; margin: 0 auto; }
        .memory-chart { background: #112240; padding: 20px; border-radius: 10px; margin: 20px 0; }
        .test-card { background: #233554; padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #64ffda; }
        .leak { border-left-color: #ff6b6b !important; background: rgba(255, 107, 107, 0.1); }
        .safe { border-left-color: #64ffda !important; background: rgba(100, 255, 218, 0.1); }
        .warning { border-left-color: #ffd166 !important; background: rgba(255, 209, 102, 0.1); }
        button { background: linear-gradient(135deg, #64ffda, #0a192f); color: #0a192f; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: bold; margin: 5px; }
        .metric { display: inline-block; padding: 8px 15px; margin: 5px; background: #1d2d50; border-radius: 5px; }
        .progress { height: 20px; background: #1d2d50; border-radius: 10px; overflow: hidden; margin: 15px 0; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, #64ffda, #4ecdc4); }
        canvas { width: 100% !important; height: 300px !important; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <h1>ğŸ’¾ ØªØ³Øª Ù†Ø´Øª Ø­Ø§ÙØ¸Ù‡ Vakamova</h1>
        <p>Ø¨Ø±Ø±Ø³ÛŒ Ù…ØµØ±Ù Ø­Ø§ÙØ¸Ù‡ Ùˆ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ù†Ø´Øª Ø¯Ø± Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ</p>
        
        <div class="memory-chart">
            <h3>ğŸ“ˆ Ù†Ù…ÙˆØ¯Ø§Ø± Ù…ØµØ±Ù Ø­Ø§ÙØ¸Ù‡</h3>
            <canvas id="memoryChart"></canvas>
        </div>
        
        <div id="testControls">
            <button onclick="startExerciseManagerTest()">ØªØ³Øª ExerciseManager</button>
            <button onclick="startUserProfileTest()">ØªØ³Øª UserProfileManager</button>
            <button onclick="startStressTest()">ØªØ³Øª Ø§Ø³ØªØ±Ø³ (ÙØ´Ø§Ø±)</button>
            <button onclick="stopAllTests()">ØªÙˆÙ‚Ù Ù‡Ù…Ù‡ ØªØ³Øªâ€ŒÙ‡Ø§</button>
            <button onclick="forceGarbageCollection()">Ø§Ø¬Ø±Ø§ÛŒ Garbage Collection</button>
        </div>
        
        <div id="results"></div>
        <div id="stats"></div>
    </div>

    <script>
        // ==================== Memory Leak Detection System ====================
        class MemoryLeakDetector {
            constructor() {
                this.samples = [];
                this.testInstances = new Map();
                this.leakThreshold = 1024 * 1024; // 1MB Ø§ÙØ²Ø§ÛŒØ´ Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ Ù†Ø´Øª
                this.samplingInterval = 1000; // Ù‡Ø± 1 Ø«Ø§Ù†ÛŒÙ‡
                this.maxSamples = 180; // 3 Ø¯Ù‚ÛŒÙ‚Ù‡ Ø¯Ø§Ø¯Ù‡
                this.chart = null;
                this.isRunning = false;
                
                // Ø¢Ù…Ø§Ø± ØªØ³Øª
                this.stats = {
                    totalTests: 0,
                    leaksDetected: 0,
                    peakMemory: 0,
                    testDuration: 0
                };
                
                this.initChart();
                this.updateStats();
            }
            
            initChart() {
                const ctx = document.getElementById('memoryChart').getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Ù…ØµØ±Ù Ø­Ø§ÙØ¸Ù‡ (MB)',
                                data: [],
                                borderColor: '#64ffda',
                                backgroundColor: 'rgba(100, 255, 218, 0.1)',
                                fill: true,
                                tension: 0.4
                            },
                            {
                                label: 'Ø¢Ø³ØªØ§Ù†Ù‡ Ù†Ø´Øª',
                                data: [],
                                borderColor: '#ff6b6b',
                                borderDash: [5, 5],
                                backgroundColor: 'transparent',
                                fill: false
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { position: 'top' },
                            tooltip: {
                                callbacks: {
                                    label: (context) => `${context.dataset.label}: ${context.parsed.y.toFixed(2)}MB`
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'Ø­Ø§ÙØ¸Ù‡ (MB)' }
                            },
                            x: {
                                title: { display: true, text: 'Ø²Ù…Ø§Ù† (Ø«Ø§Ù†ÛŒÙ‡)' }
                            }
                        }
                    }
                });
            }
            
            getMemoryUsage() {
                if (performance.memory) {
                    return {
                        used: performance.memory.usedJSHeapSize,
                        total: performance.memory.totalJSHeapSize,
                        limit: performance.memory.jsHeapSizeLimit,
                        timestamp: Date.now()
                    };
                }
                
                // Fallback Ø¨Ø±Ø§ÛŒ Ù…Ø±ÙˆØ±Ú¯Ø±Ù‡Ø§ÛŒÛŒ Ú©Ù‡ performance.memory Ù†Ø¯Ø§Ø±Ù†Ø¯
                return {
                    used: 0,
                    total: 0,
                    limit: 0,
                    timestamp: Date.now()
                };
            }
            
            takeSample(testName) {
                const memory = this.getMemoryUsage();
                const sample = {
                    testName,
                    usedMB: memory.used / 1024 / 1024,
                    totalMB: memory.total / 1024 / 1024,
                    limitMB: memory.limit / 1024 / 1024,
                    timestamp: memory.timestamp,
                    timeElapsed: this.samples.length
                };
                
                this.samples.push(sample);
                
                // Ø­ÙØ¸ Ø¢Ø®Ø±ÛŒÙ† Ù†Ù…ÙˆÙ†Ù‡â€ŒÙ‡Ø§
                if (this.samples.length > this.maxSamples) {
                    this.samples.shift();
                }
                
                // Ø¢Ù¾Ø¯ÛŒØª Ù†Ù…ÙˆØ¯Ø§Ø±
                this.updateChart();
                
                // Ø¨Ø±Ø±Ø³ÛŒ Ù†Ø´Øª
                if (this.samples.length > 10) {
                    this.checkForLeaks(testName);
                }
                
                // Ø¢Ù¾Ø¯ÛŒØª Ø¢Ù…Ø§Ø±
                this.stats.peakMemory = Math.max(this.stats.peakMemory, sample.usedMB);
                this.updateStats();
                
                return sample;
            }
            
            updateChart() {
                const labels = this.samples.map(s => s.timeElapsed);
                const usedData = this.samples.map(s => s.usedMB);
                const leakThresholdData = this.samples.map(() => 
                    (this.samples[0]?.usedMB || 0) + (this.leakThreshold / 1024 / 1024)
                );
                
                this.chart.data.labels = labels;
                this.chart.data.datasets[0].data = usedData;
                this.chart.data.datasets[1].data = leakThresholdData;
                this.chart.update('none');
            }
            
            checkForLeaks(testName) {
                if (this.samples.length < 20) return;
                
                const recentSamples = this.samples.slice(-10);
                const oldSamples = this.samples.slice(-20, -10);
                
                const recentAvg = recentSamples.reduce((sum, s) => sum + s.usedMB, 0) / recentSamples.length;
                const oldAvg = oldSamples.reduce((sum, s) => sum + s.usedMB, 0) / oldSamples.length;
                
                const memoryIncrease = recentAvg - oldAvg;
                const percentIncrease = (memoryIncrease / oldAvg) * 100;
                
                // ØªØ´Ø®ÛŒØµ Ù†Ø´Øª
                const hasLeak = memoryIncrease > (this.leakThreshold / 1024 / 1024) && percentIncrease > 10;
                
                if (hasLeak) {
                    this.stats.leaksDetected++;
                    this.reportLeak(testName, memoryIncrease, percentIncrease);
                }
                
                return hasLeak;
            }
            
            reportLeak(testName, increaseMB, percent) {
                const resultsDiv = document.getElementById('results');
                const leakTime = new Date().toLocaleTimeString('fa-IR');
                
                resultsDiv.innerHTML += `
                    <div class="test-card leak">
                        <h4>ğŸš¨ Ù†Ø´Øª Ø­Ø§ÙØ¸Ù‡ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯!</h4>
                        <p><strong>Ù…Ø§Ú˜ÙˆÙ„:</strong> ${testName}</p>
                        <p><strong>Ø²Ù…Ø§Ù†:</strong> ${leakTime}</p>
                        <p><strong>Ø§ÙØ²Ø§ÛŒØ´ Ø­Ø§ÙØ¸Ù‡:</strong> ${increaseMB.toFixed(2)}MB (${percent.toFixed(1)}%)</p>
                        <p><strong>ØªÙˆØµÛŒÙ‡:</strong> Ø¨Ø±Ø±Ø³ÛŒ references Ù†Ú¯Ù‡â€ŒØ¯Ø§Ø´ØªÙ‡ Ø´Ø¯Ù‡ØŒ event listeners Ùˆ ØªØ§ÛŒÙ…Ø±Ù‡Ø§</p>
                    </div>
                `;
                
                console.error(`ğŸš¨ Ù†Ø´Øª Ø­Ø§ÙØ¸Ù‡ Ø¯Ø± ${testName}: ${increaseMB.toFixed(2)}MB Ø§ÙØ²Ø§ÛŒØ´ (${percent.toFixed(1)}%)`);
            }
            
            reportSafe(testName, duration) {
                const resultsDiv = document.getElementById('results');
                resultsDiv.innerHTML += `
                    <div class="test-card safe">
                        <h4>âœ… ØªØ³Øª Ø­Ø§ÙØ¸Ù‡ Ù…ÙˆÙÙ‚</h4>
                        <p><strong>Ù…Ø§Ú˜ÙˆÙ„:</strong> ${testName}</p>
                        <p><strong>Ù…Ø¯Øª ØªØ³Øª:</strong> ${duration} Ø«Ø§Ù†ÛŒÙ‡</p>
                        <p><strong>ÙˆØ¶Ø¹ÛŒØª:</strong> Ø¨Ø¯ÙˆÙ† Ù†Ø´Øª Ø­Ø§ÙØ¸Ù‡ Ù‚Ø§Ø¨Ù„ ØªØ´Ø®ÛŒØµ</p>
                        <p><strong>Ù…ØµØ±Ù Ù¾ÛŒÚ©:</strong> ${this.stats.peakMemory.toFixed(2)}MB</p>
                    </div>
                `;
            }
            
            updateStats() {
                const statsDiv = document.getElementById('stats');
                const currentMemory = this.samples.length > 0 ? 
                    this.samples[this.samples.length - 1].usedMB : 0;
                
                statsDiv.innerHTML = `
                    <div class="test-card">
                        <h3>ğŸ“Š Ø¢Ù…Ø§Ø± Ø­Ø§ÙØ¸Ù‡</h3>
                        <div class="metric">Ù…ØµØ±Ù ÙØ¹Ù„ÛŒ: ${currentMemory.toFixed(2)}MB</div>
                        <div class="metric">Ù¾ÛŒÚ© Ù…ØµØ±Ù: ${this.stats.peakMemory.toFixed(2)}MB</div>
                        <div class="metric">ØªØ¹Ø¯Ø§Ø¯ ØªØ³Øªâ€ŒÙ‡Ø§: ${this.stats.totalTests}</div>
                        <div class="metric">Ù†Ø´Øªâ€ŒÙ‡Ø§ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ: ${this.stats.leaksDetected}</div>
                        <div class="metric">Ù†Ù…ÙˆÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ: ${this.samples.length}</div>
                        
                        <div class="progress">
                            <div class="progress-bar" style="width: ${Math.min(100, (currentMemory / 4000) * 100)}%"></div>
                        </div>
                        <small>${currentMemory.toFixed(2)}MB Ø§Ø² ~4GB Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ù…Ø±ÙˆØ±Ú¯Ø±</small>
                    </div>
                `;
            }
            
            startSampling(testName) {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.stats.totalTests++;
                this.testInstances.set(testName, {
                    startTime: Date.now(),
                    initialMemory: this.getMemoryUsage(),
                    samples: []
                });
                
                const sampleInterval = setInterval(() => {
                    if (!this.isRunning) {
                        clearInterval(sampleInterval);
                        return;
                    }
                    
                    const sample = this.takeSample(testName);
                    const testData = this.testInstances.get(testName);
                    testData.samples.push(sample);
                    
                    // ØªØ³Øª 60 Ø«Ø§Ù†ÛŒÙ‡â€ŒØ§ÛŒ
                    if (Date.now() - testData.startTime > 60000) {
                        this.stopTest(testName);
                    }
                    
                }, this.samplingInterval);
                
                // Ø°Ø®ÛŒØ±Ù‡ interval Ø¨Ø±Ø§ÛŒ cleanup
                this.testInstances.get(testName).intervalId = sampleInterval;
            }
            
            stopTest(testName) {
                const testData = this.testInstances.get(testName);
                if (!testData) return;
                
                clearInterval(testData.intervalId);
                this.isRunning = false;
                
                const duration = (Date.now() - testData.startTime) / 1000;
                this.stats.testDuration += duration;
                
                // Ø¨Ø±Ø±Ø³ÛŒ Ù†Ù‡Ø§ÛŒÛŒ
                const hasLeak = this.checkForLeaks(testName);
                if (!hasLeak) {
                    this.reportSafe(testName, duration.toFixed(1));
                }
                
                // Cleanup
                this.testInstances.delete(testName);
            }
            
            stopAllTests() {
                this.testInstances.forEach((testData, testName) => {
                    clearInterval(testData.intervalId);
                    this.stopTest(testName);
                });
            }
            
            forceGarbageCollection() {
                if (window.gc) {
                    window.gc();
                    console.log('ğŸ—‘ï¸ Garbage Collection Ø§Ø¬Ø±Ø§ Ø´Ø¯');
                } else {
                    console.warn('âš ï¸ ØªØ§Ø¨Ø¹ gc Ø¯Ø± Ø§ÛŒÙ† Ù…Ø±ÙˆØ±Ú¯Ø± Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª');
                    // ØªØ±ÙÙ†Ø¯ Ø¨Ø±Ø§ÛŒ ØªØ´ÙˆÛŒÙ‚ GC
                    try {
                        window.open('about:blank', '_blank')?.close();
                    } catch {}
                }
                
                // Ù†Ù…ÙˆÙ†Ù‡â€ŒÚ¯ÛŒØ±ÛŒ Ø¨Ø¹Ø¯ Ø§Ø² GC
                setTimeout(() => this.takeSample('After GC'), 100);
            }
        }
        
        // ==================== Mock Implementations for Testing ====================
        
        // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ ExerciseManager Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ù†Ø´Øª
        class LeakyExerciseManager {
            constructor() {
                this.exercises = [];
                this.subscribers = [];
                this.timers = [];
                this.eventListeners = [];
                this.cache = new Map();
                this.leakMode = false;
            }
            
            // Ø­Ø§Ù„Øª Ø¹Ø§Ø¯ÛŒ (Ø¨Ø¯ÙˆÙ† Ù†Ø´Øª)
            createExerciseNormal() {
                return {
                    id: `ex_${Date.now()}`,
                    type: 'multipleChoice',
                    question: 'Ø³ÙˆØ§Ù„ ØªØ³Øª',
                    options: ['Ú¯Ø²ÛŒÙ†Ù‡ Û±', 'Ú¯Ø²ÛŒÙ†Ù‡ Û²'],
                    correctAnswer: 'Ú¯Ø²ÛŒÙ†Ù‡ Û±',
                    timestamp: new Date().toISOString()
                };
            }
            
            // Ø­Ø§Ù„Øª Ø¨Ø§ Ù†Ø´Øª Ø¹Ù…Ø¯ÛŒ
            createExerciseLeaky() {
                const exercise = this.createExerciseNormal();
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ù†Ø´Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
                if (this.leakMode) {
                    // 1. Ù†Ú¯Ù‡â€ŒØ¯Ø§Ø´ØªÙ† reference Ø¯Ø± Ø¢Ø±Ø§ÛŒÙ‡
                    this.exercises.push(exercise);
                    
                    // 2. Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† event listener Ø¨Ø¯ÙˆÙ† cleanup
                    const fakeElement = { addEventListener: () => {} };
                    const handler = () => console.log('leaky handler');
                    fakeElement.addEventListener('click', handler);
                    this.eventListeners.push({ element: fakeElement, handler });
                    
                    // 3. ØªØ§ÛŒÙ…Ø± Ø¨Ø¯ÙˆÙ† cleanup
                    const timer = setTimeout(() => {}, 1000000);
                    this.timers.push(timer);
                    
                    // 4. cache Ø¨Ø¯ÙˆÙ† Ù…Ø­Ø¯ÙˆØ¯ÛŒØª
                    this.cache.set(`key_${Date.now()}`, {
                        data: new Array(1000).fill('X').join(''),
                        timestamp: Date.now()
                    });
                    
                    // 5. Ø­Ù„Ù‚Ù‡ Ù…Ø±Ø¬Ø¹ (circular reference)
                    exercise.self = exercise;
                    exercise.manager = this;
                }
                
                return exercise;
            }
            
            // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡â€ŒÛŒ Ø³Ù†Ú¯ÛŒÙ†
            stressTest(iterations = 1000, leakMode = false) {
                this.leakMode = leakMode;
                const results = [];
                
                for (let i = 0; i < iterations; i++) {
                    const exercise = leakMode ? 
                        this.createExerciseLeaky() : 
                        this.createExerciseNormal();
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´
                    results.push({
                        ...exercise,
                        processed: true,
                        score: Math.random() * 100,
                        evaluation: { correct: Math.random() > 0.5 }
                    });
                    
                    // Ø§ÛŒØ¬Ø§Ø¯ subscribers leak
                    if (leakMode && i % 100 === 0) {
                        this.subscribers.push({
                            id: i,
                            callback: () => {},
                            context: { data: new Array(100).fill('leak') }
                        });
                    }
                }
                
                return results;
            }
            
            // cleanup
            cleanup() {
                this.exercises = [];
                this.subscribers = [];
                this.timers.forEach(timer => clearTimeout(timer));
                this.timers = [];
                this.eventListeners = [];
                this.cache.clear();
                this.leakMode = false;
            }
        }
        
        // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ UserProfileManager Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ù†Ø´Øª
        class LeakyUserProfileManager {
            constructor() {
                this.profiles = new Map();
                this.history = [];
                this.observers = [];
                this.leakMode = false;
            }
            
            createProfileNormal(userId) {
                return {
                    id: userId,
                    name: `Ú©Ø§Ø±Ø¨Ø± ${userId}`,
                    email: `user${userId}@test.com`,
                    settings: { theme: 'light' },
                    languages: ['en', 'fa'],
                    joinDate: new Date().toISOString()
                };
            }
            
            createProfileLeaky(userId) {
                const profile = this.createProfileNormal(userId);
                
                if (this.leakMode) {
                    // Ù†Ø´Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
                    
                    // 1. Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± Map Ø¨Ø¯ÙˆÙ† Ø­Ø°Ù
                    this.profiles.set(userId, profile);
                    
                    // 2. Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ history Ø¨Ø¯ÙˆÙ† Ù…Ø­Ø¯ÙˆØ¯ÛŒØª
                    this.history.push({
                        profile,
                        timestamp: Date.now(),
                        snapshot: JSON.parse(JSON.stringify(profile)) // deep clone
                    });
                    
                    // 3. Ø§ÛŒØ¬Ø§Ø¯ observers leak
                    const observer = {
                        id: Date.now(),
                        update: () => {},
                        data: new Array(50).fill({ leak: true })
                    };
                    this.observers.push(observer);
                    
                    // 4. Ø§ÛŒØ¬Ø§Ø¯ closure leak
                    profile.getSecret = (() => {
                        const secretData = new Array(100).fill('SECRET');
                        return () => secretData;
                    })();
                    
                    // 5. circular reference
                    profile.manager = this;
                    this.selfRef = { profile, manager: this };
                }
                
                return profile;
            }
            
            stressTest(iterations = 500, leakMode = false) {
                this.leakMode = leakMode;
                const operations = [];
                
                for (let i = 0; i < iterations; i++) {
                    const userId = `user_${i}`;
                    const profile = leakMode ? 
                        this.createProfileLeaky(userId) : 
                        this.createProfileNormal(userId);
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø¹Ù…Ù„ÛŒØ§Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
                    operations.push({
                        type: 'update_profile',
                        userId,
                        profile,
                        timestamp: new Date().toISOString(),
                        changes: { lastLogin: Date.now() }
                    });
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ activity history leak
                    if (leakMode && i % 50 === 0) {
                        this.history.push({
                            type: 'activity',
                            data: new Array(100).fill({ activity: 'leak' }),
                            timestamp: Date.now()
                        });
                    }
                }
                
                return operations;
            }
            
            // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ sync leak
            simulateSyncLeak() {
                if (!this.leakMode) return;
                
                // Ø§ÛŒØ¬Ø§Ø¯ promiseâ€ŒÙ‡Ø§ÛŒ unresolved
                const promises = [];
                for (let i = 0; i < 100; i++) {
                    const promise = new Promise(() => {}); // Ù‡Ø±Ú¯Ø² resolve Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯
                    promises.push(promise);
                }
                
                // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ Ø¢Ø±Ø§ÛŒÙ‡ global
                if (!window.leakyPromises) {
                    window.leakyPromises = [];
                }
                window.leakyPromises.push(...promises);
            }
            
            cleanup() {
                this.profiles.clear();
                this.history = [];
                this.observers = [];
                this.leakMode = false;
                
                // cleanup global leaks
                if (window.leakyPromises) {
                    window.leakyPromises = [];
                }
            }
        }
        
        // ==================== Global State ====================
        const memoryDetector = new MemoryLeakDetector();
        const exerciseManager = new LeakyExerciseManager();
        const profileManager = new LeakyUserProfileManager();
        
        // ==================== Test Functions ====================
        
        function startExerciseManagerTest() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML += `
                <div class="test-card warning">
                    <h4>ğŸ§ª Ø´Ø±ÙˆØ¹ ØªØ³Øª ExerciseManager</h4>
                    <p>Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øª Ø­Ø§ÙØ¸Ù‡ Ø¨Ø§ 1000 Ø¹Ù…Ù„ÛŒØ§Øª...</p>
                    <p>Ù…Ø¯Øª ØªØ³Øª: 60 Ø«Ø§Ù†ÛŒÙ‡</p>
                </div>
            `;
            
            // Ø´Ø±ÙˆØ¹ Ù†Ù…ÙˆÙ†Ù‡â€ŒÚ¯ÛŒØ±ÛŒ
            memoryDetector.startSampling('ExerciseManager');
            
            // Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø³Ù†Ú¯ÛŒÙ†
            setTimeout(() => {
                console.log('ğŸ‹ï¸â€â™‚ï¸ Ø´Ø±ÙˆØ¹ ØªÙ…Ø±ÛŒÙ† Ø³Ù†Ú¯ÛŒÙ† ExerciseManager...');
                
                // ÙØ§Ø² 1: Ø¹Ù…Ù„ÛŒØ§Øª Ø¹Ø§Ø¯ÛŒ (Ø¨Ø¯ÙˆÙ† Ù†Ø´Øª)
                const normalResults = exerciseManager.stressTest(500, false);
                console.log(`âœ… Ø¹Ù…Ù„ÛŒØ§Øª Ø¹Ø§Ø¯ÛŒ: ${normalResults.length} ØªÙ…Ø±ÛŒÙ†`);
                
                // ÙØ§Ø² 2: Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ø§ Ù†Ø´Øª (Ø¨Ø¹Ø¯ Ø§Ø² 20 Ø«Ø§Ù†ÛŒÙ‡)
                setTimeout(() => {
                    console.log('âš ï¸ Ø´Ø±ÙˆØ¹ Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ø§ Ù†Ø´Øª Ø¹Ù…Ø¯ÛŒ...');
                    exerciseManager.leakMode = true;
                    const leakyResults = exerciseManager.stressTest(500, true);
                    console.log(`ğŸš¨ Ø¹Ù…Ù„ÛŒØ§Øª Ù†Ø´Øª: ${leakyResults.length} ØªÙ…Ø±ÛŒÙ†`);
                    
                }, 20000);
                
                // ÙØ§Ø² 3: ØªÚ©Ø±Ø§Ø± Ø¹Ù…Ù„ÛŒØ§Øª (Ø¨Ø¹Ø¯ Ø§Ø² 40 Ø«Ø§Ù†ÛŒÙ‡)
                setTimeout(() => {
                    console.log('ğŸ” ØªÚ©Ø±Ø§Ø± Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ø±Ø§ÛŒ Ø§ÙØ²Ø§ÛŒØ´ ÙØ´Ø§Ø±...');
                    exerciseManager.stressTest(300, true);
                    
                }, 40000);
                
            }, 5000);
            
            // Ù¾Ø§ÛŒØ§Ù† ØªØ³Øª Ø¨Ø¹Ø¯ Ø§Ø² 60 Ø«Ø§Ù†ÛŒÙ‡
            setTimeout(() => {
                memoryDetector.stopTest('ExerciseManager');
                exerciseManager.cleanup();
                console.log('ğŸ§¹ ExerciseManager ØªÙ…ÛŒØ² Ø´Ø¯');
            }, 65000);
        }
        
        function startUserProfileTest() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML += `
                <div class="test-card warning">
                    <h4>ğŸ‘¤ Ø´Ø±ÙˆØ¹ ØªØ³Øª UserProfileManager</h4>
                    <p>Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øª Ø­Ø§ÙØ¸Ù‡ Ø¨Ø§ Ù¾Ø±ÙˆÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…ØªØ¹Ø¯Ø¯...</p>
                    <p>Ù…Ø¯Øª ØªØ³Øª: 60 Ø«Ø§Ù†ÛŒÙ‡</p>
                </div>
            `;
            
            memoryDetector.startSampling('UserProfileManager');
            
            setTimeout(() => {
                console.log('ğŸ‘¥ Ø´Ø±ÙˆØ¹ Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø±ÙˆÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø³Ù†Ú¯ÛŒÙ†...');
                
                // ÙØ§Ø² 1: Ù¾Ø±ÙˆÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¹Ø§Ø¯ÛŒ
                const normalOps = profileManager.stressTest(300, false);
                console.log(`âœ… Ù¾Ø±ÙˆÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¹Ø§Ø¯ÛŒ: ${normalOps.length}`);
                
                // ÙØ§Ø² 2: Ù¾Ø±ÙˆÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¨Ø§ Ù†Ø´Øª
                setTimeout(() => {
                    console.log('âš ï¸ Ø´Ø±ÙˆØ¹ Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø¨Ø§ Ù†Ø´Øª...');
                    profileManager.leakMode = true;
                    const leakyOps = profileManager.stressTest(300, true);
                    console.log(`ğŸš¨ Ù¾Ø±ÙˆÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù†Ø´Øª: ${leakyOps.length}`);
                    
                    // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ sync leak
                    profileManager.simulateSyncLeak();
                    
                }, 25000);
                
                // ÙØ§Ø² 3: Ø¹Ù…Ù„ÛŒØ§Øª Ø¨ÛŒØ´ØªØ±
                setTimeout(() => {
                    console.log('ğŸ“ˆ Ø§ÙØ²Ø§ÛŒØ´ Ø¹Ù…Ù„ÛŒØ§Øª...');
                    profileManager.stressTest(200, true);
                    
                }, 45000);
                
            }, 5000);
            
            setTimeout(() => {
                memoryDetector.stopTest('UserProfileManager');
                profileManager.cleanup();
                console.log('ğŸ§¹ UserProfileManager ØªÙ…ÛŒØ² Ø´Ø¯');
            }, 65000);
        }
        
        function startStressTest() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML += `
                <div class="test-card leak">
                    <h4>ğŸ’¥ Ø´Ø±ÙˆØ¹ ØªØ³Øª Ø§Ø³ØªØ±Ø³ Ø´Ø¯ÛŒØ¯</h4>
                    <p>Ø§ÛŒÙ† ØªØ³Øª Ù†Ø´Øªâ€ŒÙ‡Ø§ÛŒ Ø´Ø¯ÛŒØ¯ Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒâ€ŒÚ©Ù†Ø¯!</p>
                    <p>Ù…Ø¯Øª ØªØ³Øª: 90 Ø«Ø§Ù†ÛŒÙ‡</p>
                </div>
            `;
            
            memoryDetector.startSampling('StressTest');
            
            // ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø­Ø§Ù„Øª Ù†Ø´Øª Ø¯Ø± Ù‡Ø± Ø¯Ùˆ Ù…Ø¯ÛŒØ±
            exerciseManager.leakMode = true;
            profileManager.leakMode = true;
            
            // Ø§ÛŒØ¬Ø§Ø¯ ÙØ´Ø§Ø± Ø´Ø¯ÛŒØ¯
            let iteration = 0;
            const stressInterval = setInterval(() => {
                iteration++;
                
                // Ø¹Ù…Ù„ÛŒØ§Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ù†Ø´Øª
                exerciseManager.stressTest(100, true);
                profileManager.stressTest(50, true);
                
                // Ø§ÛŒØ¬Ø§Ø¯ closures leak
                for (let i = 0; i < 10; i++) {
                    const leakyClosure = (() => {
                        const bigArray = new Array(1000).fill('STRESS_TEST');
                        return () => bigArray;
                    })();
                    window[`leak_${Date.now()}`] = leakyClosure;
                }
                
                // Ø§ÛŒØ¬Ø§Ø¯ event listeners leak
                if (iteration % 5 === 0) {
                    for (let i = 0; i < 20; i++) {
                        window.addEventListener(`fake_event_${i}`, () => {});
                    }
                }
                
                console.log(`ğŸ’¥ Ø§Ø³ØªØ±Ø³ ØªÚ©Ø±Ø§Ø± ${iteration} - ÙØ´Ø§Ø± Ø¨Ø§Ù„Ø§`);
                
                // Ù¾Ø§ÛŒØ§Ù† ØªØ³Øª Ø¨Ø¹Ø¯ Ø§Ø² 90 Ø«Ø§Ù†ÛŒÙ‡
                if (iteration >= 18) { // 18 * 5 = 90 Ø«Ø§Ù†ÛŒÙ‡
                    clearInterval(stressInterval);
                    memoryDetector.stopTest('StressTest');
                    
                    // cleanup
                    exerciseManager.cleanup();
                    profileManager.cleanup();
                    
                    // Ø­Ø°Ù global leaks
                    Object.keys(window).forEach(key => {
                        if (key.startsWith('leak_')) {
                            delete window[key];
                        }
                    });
                    
                    console.log('ğŸ§¹ ØªØ³Øª Ø§Ø³ØªØ±Ø³ ØªÙ…ÛŒØ² Ø´Ø¯');
                }
                
            }, 5000); // Ù‡Ø± 5 Ø«Ø§Ù†ÛŒÙ‡
        }
        
        function stopAllTests() {
            memoryDetector.stopAllTests();
            exerciseManager.cleanup();
            profileManager.cleanup();
            
            document.getElementById('results').innerHTML += `
                <div class="test-card">
                    <h4>â¹ï¸ Ù‡Ù…Ù‡ ØªØ³Øªâ€ŒÙ‡Ø§ Ù…ØªÙˆÙ‚Ù Ø´Ø¯Ù†Ø¯</h4>
                    <p>ØªÙ…Ø§Ù… Ù…Ù†Ø§Ø¨Ø¹ Ø¢Ø²Ø§Ø¯ Ø´Ø¯Ù†Ø¯.</p>
                </div>
            `;
        }
        
        function forceGarbageCollection() {
            memoryDetector.forceGarbageCollection();
            
            document.getElementById('results').innerHTML += `
                <div class="test-card">
                    <h4>ğŸ—‘ï¸ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Garbage Collection</h4>
                    <p>Ø¯Ø± Ø­Ø§Ù„ Ø¢Ø²Ø§Ø¯Ø³Ø§Ø²ÛŒ Ø­Ø§ÙØ¸Ù‡...</p>
                </div>
            `;
        }
        
        // ==================== Startup ====================
        
        // Ø¨Ø±Ø±Ø³ÛŒ support Ø¨Ø±Ø§ÛŒ memory API
        if (!performance.memory) {
            document.getElementById('results').innerHTML = `
                <div class="test-card leak">
                    <h4>âš ï¸ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ù…Ø±ÙˆØ±Ú¯Ø±</h4>
                    <p>Ù…Ø±ÙˆØ±Ú¯Ø± Ø´Ù…Ø§ performance.memory Ø±Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯.</p>
                    <p>Ù„Ø·ÙØ§Ù‹ Ø§Ø² Google Chrome Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.</p>
                    <p>Ø¨Ø§ Ø§ÛŒÙ† Ø­Ø§Ù„ ØªØ³Øªâ€ŒÙ‡Ø§ Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ø­Ø¯ÙˆØ¯ Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.</p>
                </div>
            `;
        }
        
        // Ù†Ù…Ø§ÛŒØ´ Ø±Ø§Ù‡Ù†Ù…Ø§
        document.getElementById('results').innerHTML += `
            <div class="test-card">
                <h3>ğŸ“‹ Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ ØªØ³Øª Ù†Ø´Øª Ø­Ø§ÙØ¸Ù‡</h3>
                <p><strong>ExerciseManager:</strong> ØªØ³Øª ØªÙ…Ø±ÛŒÙ†â€ŒÙ‡Ø§ Ùˆ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒâ€ŒÙ‡Ø§</p>
                <p><strong>UserProfileManager:</strong> ØªØ³Øª Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ùˆ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ</p>
                <p><strong>ØªØ³Øª Ø§Ø³ØªØ±Ø³:</strong> Ø§ÛŒØ¬Ø§Ø¯ ÙØ´Ø§Ø± Ø´Ø¯ÛŒØ¯ Ùˆ Ù†Ø´Øªâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ø¯ÛŒ</p>
                <p><strong>ğŸŸ¢ Ø³Ø¨Ø²:</strong> Ø¨Ø¯ÙˆÙ† Ù†Ø´Øª | <strong>ğŸ”´ Ù‚Ø±Ù…Ø²:</strong> Ù†Ø´Øª Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯</p>
                <p>Ù‡Ø± ØªØ³Øª 60-90 Ø«Ø§Ù†ÛŒÙ‡ Ø·ÙˆÙ„ Ù…ÛŒâ€ŒÚ©Ø´Ø¯.</p>
            </div>
        `;
        
        // Ø´Ø±ÙˆØ¹ Ù†Ù…ÙˆÙ†Ù‡â€ŒÚ¯ÛŒØ±ÛŒ Ù¾Ø§ÛŒÙ‡
        setInterval(() => {
            if (!memoryDetector.isRunning) {
                memoryDetector.takeSample('Idle');
            }
        }, 5000);
        
        console.log('ğŸ’¾ ØªØ³Øª Ù†Ø´Øª Ø­Ø§ÙØ¸Ù‡ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª. Ø§Ø² Chrome Ø¨Ø±Ø§ÛŒ Ø¨Ù‡ØªØ±ÛŒÙ† Ù†ØªØ§ÛŒØ¬ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.');
    </script>
</body>
</html>
